{"version":3,"sources":["../src/util.js","../src/circular-path/circle.js","../src/circular-path/index.js","../src/drawer/service.js","../src/drawer/vector.js","../src/drawer/rectangle.js","../src/drawer/snapped-drawer/bottom.js","../src/drawer/snapped-drawer/left.js","../src/drawer/snapped-drawer/right.js","../src/drawer/snapped-drawer/top.js","../src/drawer/snapped-drawer/index.js","../src/drawer/index.js","../src/nav/backdrop.js","../src/nav/drawer.js","../src/nav/navservice.js","../src/nav/popservice.js","../src/nav/state.js","../src/nav/index.js","../src/sheet/drawer.js","../src/sheet/sheetservice.js","../src/sheet/index.js","../src/index.js"],"names":["BLUR_SPREAD_SHADE","NAV_BOX_SHADOW","top","left","bottom","right","DIRECTIONS","NAVSTATE_EVENTS","show","hide","DrawerResponseInterface","WINDOW","window","Path","x","y","this","pathDifference","path1","path2","join","Bound","lower","upper","_createClass","key","get","ActivityManager","activity","running","id","Date","now","_proto","prototype","run","derun","isRunning","dataCamelCase","data","camelCase","substring","delim","Array","split","reduce","acc","cur","charAt","toUpperCase","slice","$","query","document","querySelectorAll","getAttribute","el","attr","getData","dataName","prop","dataset","offsetRight","screen","width","offsetLeft","offsetWidth","offsetBottom","height","offsetTop","offsetHeight","resolveThreshold","threshold","css","arguments","length","undefined","property","value","STYLEMAP","getComputedStyle","style","Object","_arr","keys","_i","isArray","ostyle","_iterator","_isArray","_i2","Symbol","iterator","_ref","next","done","PI","Math","RAD","DEG","Quadrant","CircularPath","radius","_this","_Circle","call","_len","angles","_key","_angles","map","_degToRad","_quad","deg","_radToDeg","rad","_findPath","angle","parseFloat","cos","toFixed","sin","getQuadrant","RangeError","_this2","out","forEach","_this2$_findPath","push","Circle","diameter","areaOfSect","area","arc","circumference","pow","Service","event","_event","lock","stopImmediatePropagation","inhibitSubTask","preventDefault","VectorRectangle","_Rectangle","paths","apply","concat","_inheritsLoose","coordsX","x2","x1","coordsY","y2","y1","displacementY","displacementX","sqrt","Rectangle","_paths$","_paths$2","abs","greaterWidth","THRESHOLD","BELOW_THRESHOLD","OPEN","CLOSE","Bottom","options","bound","element","ELEMENT","_winSize","sizeOfWindow","_windowSize","winSize","SIZE","unit","minArea","maxStartArea","startX","startY","resumeX","resumeY","endX","endY","scrollControlSet","scrollControl","timing","start","end","_context","touchEvent","fn","_updateOrientation","WIN_HEIGHT","changedTouches","clientY","clientX","currentPosition","positionOnStart","dimension","displacement","slack","_response","response","DRI","move","FALSE_HEIGHT","resume","virtualStart","vdimension","rect","isBoundY","greaterHeight","gap","_response2","_response4","thresholdState","_response5","TIMING","getTime","signedOffsetSide","customBound","nonZero","zero","offsetSide","action","getResponse","state","trueForOpen","_extends2","_extends3","_extends","stateObj","service","setContext","ctx","_getStyle","elt","pseudoElt","Left","maxArea","isBoundX","Right","WIN_WIDTH","FALSE_WIDTH","Top","SnappedDrawer","drawerManager","_options","_drawerManager","_element","_target","TARGET","_handlers","_direction","DIRECTION","_calibration","_callbacks","_id","events","_setCalibration","activate","startfn","def","movefn","endfn","_register","getRunningActivity","_isCoolSignal","_getSignal","_processThresholdState","i","addEventListener","deactivate","removeEventListener","on","_registerCallbacks","setServiceID","TypeError","toString","stateArray","point","UP","LEFT","DOWN","RIGHT","signal","size","emitter","handlers","Drawer","DrawerManagementStore","activities","pushActivity","find","Backdrop","backdrop","time","display","opacity","transition","setTimeout","setOpacity","val","TRANSITION_STYLE","EFFECT","OVERFLOW","HIDDEN","NavDrawer","_body","BODY","_backdrop","BACKDROP","direction","_checkDirection","directionString","_bound","o","elementSize","drawer","_startHandler","_moveHandler","_threshold","_belowThreshold","_css","boxShadow","overflow","rectangle","_css2","curPos","isOpen","_calcSpeed","_hide","_show","LOGIC","isClosed","overallEventTime","_overrideBelowThresh","_showPrep","_hidePrep","oppositeDimension","_css3","TRANSITION","_setState","isRegisteredEvent","getStateEventHandler","_css4","buttonHash","INIT_ELEM","location","hash","distance","distanceRemain","sign","newTime","mode","Error","axis","upperBound","lowerBound","TRANS_END","NavService","nav","button","body","backdropElement","transTime","alive","_closeInvoked","_initialState","ClickHandler","mouseEvent","handler","BackdropHandler","_close","TransitionHandler","_cleanShadow","_width","ReferenceError","forceDeactivate","_toNum","_open","replace","test","round","parseInt","_style","_style2","PopService","parentService","hashChangeEvent","_hashchange","_getHash","oldURL","uri","indexOfHash","lastIndexOf","EventInterface","SHOW","HIDE","State","_this$_stateEventRegi","_stateEventRegistry","type","values","indexOf","NAV","NavCard","src","dest","createElement","className","background","position","SheetService","_Activity","setup","opts","assign","defaultConfig","hasOwnProperty","srcEl","HTMLElement","destEl","maxWidth","useBackdrop","backdropclass","insertAdjacentElement","defaultOptions","drawerOptions","MAX_WIDTH","scrollableContainer","CustomDrawer","NavMountWorker","hashOptions","terminate","SERVICES","Default","Hash","namespace","name","_drawerAPI","_hashAPI","_defaultAPI","_this3","Pop","borrowedContext","$this","mount","_this4","DEFAULT_ACTIVE","DRAWER_ACTIVE","HASH_ACTIVE","Promise","resolve","reject","NavStateEvent","unmount","_State","handle","bind","off","AUTO","MarkIndex","SheetDrawer","_this$marks","_scCheck","_sc","_oldbound","marks","documentElement","clientHeight","_Control","touchMoveExited","lastMetredPos","WIN_SIZE","posOnStart","scrollTop","customDimension","closing","_toUnit","opening","scrollTo","velocity","MPD","MND","_halfHidePrep","_options$stateObj","isDownDrawer","halfDimension","_css5","bodyOverflow","_updateBound","sheet","_height","NAME","SHEET","Sheet","_NavCard","navMountWorker","SheetMountWorker","Interface","SheetStateEvent","Util","ZERO","unique","max","floor","random","hasAttribute","setAttribute"],"mappings":"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","sourcesContent":["// constants\nconst BLUR_SPREAD_SHADE = '0.7rem 0 rgba(0,0,0,.3)'\nexport const NAV_BOX_SHADOW = {\n  top: `0 0.2rem ${BLUR_SPREAD_SHADE}`,\n  left: `0.2rem 0 ${BLUR_SPREAD_SHADE}`,\n  bottom: `0 -0.2rem ${BLUR_SPREAD_SHADE}`,\n  right: `-0.2rem 0 ${BLUR_SPREAD_SHADE}`\n}\nexport const ZERO = 0\nexport const DIRECTIONS = [\n  'top', 'left',\n  'bottom', 'right'\n]\nexport const NAVSTATE_EVENTS = {\n  show: 'show',\n  hide: 'hide'\n}\nexport const DrawerResponseInterface = {\n  position: 'position',\n  posOnStart: 'posOnStart',\n  dimension: 'dimension',\n  displacement: 'displacement',\n  oppositeDimension: 'oppositeDimension',\n  close: 'closing',\n  open: 'opening'\n}\nexport const WINDOW = window\n\n// classes\nexport class Path {\n  constructor(x, y) {\n    this.x = x\n    this.y = y\n  }\n\n  /**\n   * Get difference between two paths\n   * @param {Path} path1 Path Object\n   * @param {Path} path2 Path Object\n   * @returns {Path} A different Path\n   */\n  static pathDifference(path1, path2) {\n    const x = path1.x - path2.x\n    const y = path1.y - path2.y\n    return new Path(x, y)\n  }\n\n  /**\n   * Join two different paths\n   * @param {Path} path1 Path Object\n   * @param {Path} path2 Path Object\n   * @returns {Path} A joined Path\n   */\n  static join(path1, path2) {\n    const x = path1.x + path2.x\n    const y = path1.y + path2.y\n    return new Path(x, y)\n  }\n}\n\nexport class Bound {\n  constructor(lower, upper) {\n    this.lower = lower\n    this.upper = upper\n  }\n\n  get gap() {\n    return this.upper - this.lower\n  }\n\n  get slack() {\n    return this.lower - this.upper\n  }\n}\n\nexport class ActivityManager {\n  constructor(activity) {\n    this.activity = activity\n    this.running = false\n    this.id = Date.now()\n  }\n\n  run() {\n    this.running = true\n  }\n\n  derun() {\n    this.running = false\n  }\n\n  isRunning() {\n    return this.running\n  }\n}\n\n// functions\nexport function dataCamelCase(data) {\n  // remove 'data-' prefix and return camelCase string\n  return camelCase(data.substring(5), '-')\n}\n\nexport function camelCase(data, delim = '-') {\n  const list = data instanceof Array ? data : data.split(delim)\n  return list.reduce((acc, cur) => acc + cur.charAt(0)\n    .toUpperCase() + cur.slice(1)\n  )\n}\n\nexport function unique(max = 1) {\n  return Math.floor(Math.random() * max)\n}\n\nexport function $(query) {\n  return document.querySelectorAll(query)[0]\n}\n\nexport function getAttribute(el, attr) {\n  return el.getAttribute(attr)\n}\n\nexport function hasAttribute(el, attr) {\n  return el.hasAttribute(attr)\n}\n\nexport function setAttribute(el, attr, value) {\n  el.setAttribute(attr, value)\n}\n\nexport function getData(el, dataName) {\n  const prop = dataCamelCase(dataName)\n  // this may return `undefined` in some Safari\n  if (el.dataset && el.dataset[prop]) {\n    return el.dataset[prop]\n  }\n  return getAttribute(el, dataName.substring(5))\n}\n\nexport function offsetRight(el) {\n  return WINDOW.screen.width - el.offsetLeft - el.offsetWidth\n}\n\nexport function offsetBottom(el) {\n  return WINDOW.screen.height - el.offsetTop - el.offsetHeight\n}\n\nexport function resolveThreshold(threshold) {\n  const MAX_THRESHOLD = 1\n  const MIN_ILLEGAL_THRESHOLD = 0\n  if (threshold < MAX_THRESHOLD && threshold > MIN_ILLEGAL_THRESHOLD) {\n    threshold = MAX_THRESHOLD - threshold\n    return threshold\n  } else if (threshold < MIN_ILLEGAL_THRESHOLD) {\n    threshold = MAX_THRESHOLD\n    return threshold\n  }\n  return MAX_THRESHOLD\n}\n\n/**\n * @param {HTMLElement} el an HTMLElement whose style should\n * be accessed\n * @param {string | string[] | {}} property A property/properties\n * to set or get\n * @param {string | number} value value to set as\n * @returns {CSSStyleDeclaration | string} A css style property\n * or CSSStyleDeclaration object\n */\nexport function css(...args) {\n  if (args.length < 1) {\n    return null\n  }\n  const el = args[0]\n  const property = args[1]\n  let value = args[2]\n  const STYLEMAP = WINDOW.getComputedStyle(el)\n\n  if (typeof property === 'string' && value) {\n    // setting one property\n    el.style[property] = value\n    return null\n  }\n  if (typeof property === 'object' && property instanceof Object) {\n    // `style` MUST = null\n    // setting many properties\n    value = property\n    for (const prop of Object.keys(value)) {\n      el.style[prop] = value[prop]\n    }\n    return null\n  } else if (Array.isArray(property)) {\n    // return all values of properties in the array for\n    // the element as object\n    const ostyle = {}\n    for (const prop of STYLEMAP) {\n      ostyle[prop] = STYLEMAP[prop]\n    }\n    return ostyle\n  } else if (typeof property === 'string') {\n    // get value of property\n    return STYLEMAP[property]\n  }\n  return STYLEMAP\n}\n","export const POINT_ANGLE = 360\nexport const PI = Math.PI\nexport const RAD = PI / (POINT_ANGLE >> 1)\n\nexport class Circle {\n  constructor(radius) {\n    this.radius = radius\n    this.diameter = this.radius * 2\n  }\n\n  get area() {\n    return PI * this.radius ** 2\n  }\n\n  get circumference() {\n    return 2 * PI * this.radius\n  }\n\n  areaOfSect(angle) {\n    angle *= RAD\n    return angle / POINT_ANGLE * this.area\n  }\n\n  arc(angle) {\n    angle *= RAD\n    return angle / POINT_ANGLE * this.circumference\n  }\n}\n","import {\n  Circle,\n  RAD\n} from './circle'\nimport {\n  Path\n} from '../util'\n\nconst DEG = 1 / RAD\n/**\n * Enum of all quadrants from first to fourth.\n * The quadrant is not a usual one; it starts from the 12th\n * hand of the clock and moves anti-clockwise\n * @enum {number}\n * @const\n */\nconst Quadrant = {\n  FIRST: 360,\n  SECOND: 90,\n  THIRD: 180,\n  FOURTH: 270\n}\n\nexport default class CircularPath extends Circle {\n  constructor(radius, ...angles) {\n    super(radius)\n    this._angles = angles\n    this.angles = angles.map((value) => this._degToRad(value))\n    this._quad = null\n  }\n\n  get paths() {\n    /**\n     * @type {Path[]}\n     */\n    const out = []\n    this.angles.forEach((value) => {\n      const [\n        x, y\n      ] = this._findPath(value)\n      out.push(new Path(x, y))\n    })\n    return out\n  }\n\n  // private\n  _degToRad(deg) {\n    return RAD * deg\n  }\n\n  _radToDeg(rad) {\n    return DEG * rad\n  }\n\n  _findPath(angle) {\n    // const quad = this.getQuadrant(DEG_ANGLE)\n    return [\n      parseFloat((this.radius * Math.cos(angle)).toFixed(3)),\n      parseFloat((this.radius * Math.sin(angle)).toFixed(3))\n    ]\n  }\n\n  getQuadrant(angle) {\n    if (angle <= Quadrant.FIRST) {\n      return Quadrant.FIRST\n    } else if (angle <= Quadrant.SECOND && angle > Quadrant.FIRST) {\n      return Quadrant.SECOND\n    } else if (angle <= Quadrant.THIRD && angle > Quadrant.SECOND) {\n      return Quadrant.THIRD\n    } else if (angle <= Quadrant.FOURTH && angle > Quadrant.THIRD) {\n      return Quadrant.FOURTH\n    }\n    throw RangeError('Quadrant out of range')\n  }\n}\n","export class Service {\n  constructor(event) {\n    this._event = event\n  }\n\n  lock() {\n    this._event.stopImmediatePropagation()\n  }\n\n  inhibitSubTask() {\n    this._event.preventDefault()\n  }\n}\n","import {\n  Rectangle\n} from './rectangle'\n\nexport class VectorRectangle extends Rectangle {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(...paths) {\n    super(...paths)\n  }\n\n  get displacementX() {\n    return this.coordsX.x2 - this.coordsX.x1\n  }\n\n  get displacementY() {\n    return this.coordsY.y2 - this.coordsY.y1\n  }\n\n  get resultant() {\n    if (!this.displacementY) {\n      return this.displacementX\n    } else if (!this.displacementX) {\n      return this.displacementY\n    }\n    return Math.sqrt(\n      this.displacementY ** 2 + this.displacementX ** 2\n    )\n  }\n}\n","export class Rectangle {\n  constructor(...paths) {\n    if (paths.length === 4) {\n      const [x1, y1, x2, y2] = paths\n      this.coordsX = {\n        x1,\n        x2\n      }\n      this.coordsY = {\n        y1,\n        y2\n      }\n    } else if (paths.length === 2) {\n      const {\n        x1, y1\n      } = paths[0]\n      const {\n        x2, y2\n      } = paths[1]\n      this.coordsX = {\n        x1,\n        x2\n      }\n      this.coordsY = {\n        y1,\n        y2\n      }\n    }\n  }\n\n  // getter\n  get width() {\n    return Math.abs(this.coordsX.x2 - this.coordsX.x1)\n  }\n\n  get height() {\n    return Math.abs(this.coordsY.y2 - this.coordsY.y1)\n  }\n\n  get perimeter() {\n    return 2 * (this.width + this.height)\n  }\n\n  get area() {\n    return this.width * this.height\n  }\n\n  get greaterWidth() {\n    return this.width > this.height\n  }\n\n  get greaterHeight() {\n    return !this.greaterWidth\n  }\n}\n","import {\n  Bound,\n  DrawerResponseInterface as DRI,\n  Path,\n  WINDOW,\n  ZERO,\n  offsetBottom,\n  resolveThreshold\n} from './../../util'\nimport {\n  Service\n} from './../service'\nimport {\n  VectorRectangle\n} from './../vector'\n\nconst THRESHOLD = 'threshold'\nconst BELOW_THRESHOLD = 'belowthreshold'\nconst OPEN = 'open'\nconst CLOSE = 'close'\nconst UNIT = 'px'\nconst MAX_START_AREA = 25\nconst THRESHOLD_VALUE = 0.667\nconst FALSE_TOUCH_START_POINT = 2\n\nexport default class Bottom {\n  /**\n   * @param {{}} options\n   * an object containing all required properties\n   * @param {Bound} bound a boundary object\n   */\n  constructor(options, bound) {\n    this.options = options\n    this.bound = bound\n    /**\n     * Drawer Element\n     * @type {HTMLElement}\n     */\n    this.element = options.ELEMENT\n    /**\n     * Size of device window\n     * @type {Function}\n     */\n    this._winSize = this.options.sizeOfWindow || Bottom._windowSize\n    /**\n     * @type {number}\n     */\n    this.winSize = this._winSize()\n    /**\n     * @type {number}\n     */\n    this.height = this.options.SIZE\n    this.unit = this.options.unit || UNIT\n    /**\n     * @type {number}\n     * A minimum area where the draw-start is sensitive\n     */\n    this.minArea = this.winSize - (this.bound.lower || this.options.maxStartArea || MAX_START_AREA)\n\n    /**\n     * A threshold which the `touchmove` signal must attain\n     * before being qualified to stay shown\n     * the threshold should be a value between `0` and `1.0`\n     * @type {number}\n     */\n    this.threshold = this.options.threshold || THRESHOLD_VALUE\n    this.threshold = resolveThreshold(this.threshold)\n\n    // Touch coordinates (Touch Start)\n    this.startX = -1\n    this.startY = -1\n    // Touch coordinates (Touch Move)\n    this.resumeX = -1\n    this.resumeY = -1\n    // Touch coordinates (Touch End) [these may not be important]\n    this.endX = -1\n    this.endY = -1\n\n    /**\n     * A control for scroll. This control prevents\n     * a clash between coordinates dancing between\n     * the (&delta;`X`) coords and (&delta;`Y`) coords.\n     * Utilising the `Rectangle` class to get bounds\n     * and isolate territories\n     * @type {boolean}\n     */\n    this.scrollControlSet = false\n    this.scrollControl = null\n    this.timing = {\n      /**\n       * @type {Date}\n       */\n      start: null,\n      /**\n       * @type {Date}\n       */\n      end: null\n    }\n\n    this._context = this\n  }\n\n  /**\n   * The `touchstart` event handler for the `Bottom` drawer `class`\n   * @param {TouchEvent} touchEvent an event `object`: An event `object`\n   * representing an `object` of all `properties` related\n   * to the `touchstart` event.\n   * @param {Function} fn - a callback function called when the `start`\n   * event is triggered\n   * @returns {void}\n   */\n  start(touchEvent, fn) {\n    this.timing.start = new Date()\n    this._updateOrientation()\n    const WIN_HEIGHT = this.winSize\n    const start = touchEvent.changedTouches[0].clientY\n    this.startX = touchEvent.changedTouches[0].clientX\n    this.startY = start\n    /**\n     * The `Drawer`'s `Bottom` class uses the `CSS property`, `bottom`\n     * for updating and defining position of the drawn element\n     */\n    const currentPosition = offsetBottom(this.element)\n    const bound = this.bound\n    this.positionOnStart = currentPosition\n    const dimension = bound.lower ? `-${bound.upper - bound.lower}${this.unit}` : `-${bound.upper - (WIN_HEIGHT - start)}${this.unit}`\n    const displacement = `-${bound.upper - FALSE_TOUCH_START_POINT}${this.unit}`\n\n    if (start <= WIN_HEIGHT && start >= this.minArea && currentPosition === bound.slack) {\n      const response = {\n        [DRI.position]: currentPosition,\n        [DRI.dimension]: dimension,\n        [DRI.displacement]: displacement\n      }\n      fn.call(this._context, new Service(touchEvent), response, new Path(this.startX, this.startY))\n    }\n  }\n\n  /**\n   * The `touchmove` event handler for the `Bottom` drawer `class`\n   * @param {TouchEvent} touchEvent an event `object`: An event `object`\n   * representing an `object` of all `properties` related\n   * to the `touchmove` event.\n   * @param {Function} fn - a callback function called when the `move`\n   * event is triggered\n   * @returns {void}\n   */\n  move(touchEvent, fn) {\n    /* eslint complexity: [\"error\", 25] */\n    const WIN_HEIGHT = this.winSize\n    const FALSE_HEIGHT = WIN_HEIGHT - this.bound.upper // should be `-this.positionOnStart`\n    const resume = touchEvent.changedTouches[0].clientY\n    this.resumeX = touchEvent.changedTouches[0].clientX\n    this.resumeY = resume\n\n    const currentPosition = offsetBottom(this.element)\n    const bound = this.bound\n    // const nextAction = this.positionOnStart === ZERO ? CLOSE : OPEN\n\n    const start = this.startY\n    // const height = bound.upper || this.height\n    /**\n     * When the touch doesn't start from the max-height\n     * of the element ignore `start` and use `height`\n     * as starting point.\n     */\n    const virtualStart = start < FALSE_HEIGHT ? FALSE_HEIGHT : start\n\n    const dimension = `${start - resume + this.positionOnStart}${this.unit}`\n    // const dimension = `-${height - bound.lower - (WIN_HEIGHT - resume)}${this.unit}`\n\n    /**\n     * Dimension for closing. When the drawer is being closed,\n     * the `height` is the max dimension and the `start` could\n     * possibly be more than the `height`\n     * or less than the `height`.\n     * To assure an accurate dimension the `virtualStart`\n     * determines whether to use the `height` as starting point\n     * or the actual `start`. If the actual start is more than\n     * `height`, the height becomes the start point else the `start`\n     */\n    const vdimension = `-${-virtualStart + resume - this.positionOnStart}${this.unit}`\n    const rect = new VectorRectangle(\n      this.startX,\n      this.startY,\n      this.resumeX,\n      this.resumeY\n    )\n    const isBoundY = rect.greaterHeight\n\n    if (!this.scrollControlSet) {\n      this.scrollControl = isBoundY\n      this.scrollControlSet = !this.scrollControlSet\n    }\n\n    // OPEN LOGIC\n    if (start <= WIN_HEIGHT && (start >= this.minArea || start >= FALSE_HEIGHT - currentPosition) &&\n    currentPosition < ZERO && rect.width < bound.gap && isBoundY &&\n    this.scrollControl && rect.displacementY < ZERO) {\n      const response = {\n        [DRI.position]: currentPosition,\n        [DRI.posOnStart]: this.positionOnStart,\n        [DRI.dimension]: dimension,\n        [DRI.open]: true,\n        [DRI.close]: false\n      }\n      fn.call(this._context, new Service(touchEvent), response, rect)\n    }\n\n    // CLOSE LOGIC\n    if (resume >= FALSE_HEIGHT && Math.abs(currentPosition) < bound.gap && rect.width < bound.gap &&\n    isBoundY && this.scrollControl && rect.displacementY > ZERO) {\n      const response = {\n        [DRI.position]: currentPosition,\n        [DRI.posOnStart]: this.positionOnStart,\n        [DRI.dimension]: vdimension,\n        [DRI.close]: true,\n        [DRI.open]: false\n      }\n      fn.call(this._context, new Service(touchEvent), response, rect)\n    }\n  }\n\n  /**\n   * The `touchend` event handler for the `Bottom` drawer `class`\n   * @param {TouchEvent} touchEvent an event `object`: An event `object`\n   * representing an `object` of all `properties` related\n   * to the `touchend` event.\n   * @param {Function} fn - a callback function called when the `end`\n   * event is triggered\n   * @param {{}} thresholdState - a state object which should be passed\n   * by reference for updating by this method\n   * @returns {void}\n   */\n  end(touchEvent, fn, thresholdState) {\n    this.timing.end = new Date()\n    const WIN_HEIGHT = this.winSize\n    const FALSE_HEIGHT = WIN_HEIGHT - this.bound.upper\n    const end = touchEvent.changedTouches[0].clientY\n    this.endX = touchEvent.changedTouches[0].clientX\n    this.endY = end\n\n    const rect = new VectorRectangle(this.startX, this.startY, this.endX, this.endY)\n\n    const start = this.startY\n    const TIMING = this.timing.end.getTime() - this.timing.start.getTime()\n    const threshold = this.threshold\n    const signedOffsetSide =  offsetBottom(this.element)\n    const bound = this.bound\n    const customBound = new Bound(bound.upper + this.positionOnStart, bound.upper)\n    const nonZero = `${bound.slack}${this.unit}`\n    const zero = `${ZERO}`\n    const height = bound.upper || this.height\n    const offsetSide = Math.abs(signedOffsetSide)\n    let action = OPEN\n    // release the control for another session\n    this.scrollControl = this.scrollControlSet = false // eslint-disable-line no-multi-assign\n\n    const response = {\n      [DRI.position]: signedOffsetSide,\n      [DRI.posOnStart]: this.positionOnStart,\n      rect\n    }\n\n    function getResponse(state, trueForOpen) {\n      if (state === THRESHOLD && trueForOpen || state === BELOW_THRESHOLD && !trueForOpen) {\n        return {\n          [DRI.dimension]: zero,\n          TIMING,\n          [DRI.oppositeDimension]: nonZero,\n          ...response\n        }\n      } else if (state === THRESHOLD && !trueForOpen || state === BELOW_THRESHOLD && trueForOpen) {\n        return {\n          [DRI.dimension]: nonZero,\n          TIMING,\n          [DRI.oppositeDimension]: zero,\n          ...response\n        }\n      }\n      return {}\n    }\n\n    // OPEN LOGIC\n    if (rect.displacementY <= ZERO && (start >= this.minArea || start >= FALSE_HEIGHT - signedOffsetSide)) {\n      /**\n       * Threshold resolution is done here to get the original\n       * set value of the threshold before the first resolution\n       * Here it's the original value of threshold needed, if\n       * it was a legal value.\n       * value = 0.75\n       * value = resolve(value) => 0.25\n       * resolve(value) => 0.75\n       */\n      if (rect.height >= customBound.gap * resolveThreshold(threshold)) {\n        thresholdState.state = [THRESHOLD, CLOSE]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], true)\n      } else {\n        thresholdState.state = [BELOW_THRESHOLD, CLOSE]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], true)\n      }\n      thresholdState.service = new Service(touchEvent)\n      fn.call(this, action)\n      return\n    }\n\n    // CLOSE LOGIC\n    if (rect.displacementY >= ZERO && this.resumeY >= FALSE_HEIGHT) {\n      action = CLOSE\n      if (offsetSide >= height * threshold) {\n        thresholdState.state = [THRESHOLD, OPEN]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], false)\n      } else {\n        thresholdState.state = [BELOW_THRESHOLD, OPEN]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], false)\n      }\n      thresholdState.service = new Service(touchEvent)\n      fn.call(this, action)\n    }\n  }\n\n  setContext(ctx) {\n    this._context = ctx\n    return this\n  }\n\n  static _getStyle(elt, pseudoElt) {\n    return pseudoElt ? WINDOW.getComputedStyle(elt, pseudoElt) : WINDOW.getComputedStyle(elt)\n  }\n\n  static _windowSize() {\n    return WINDOW.screen.height\n  }\n\n  // no need for `window.onorientationchange`\n  _updateOrientation() {\n    this.winSize = typeof this._winSize === 'function' ? this._winSize() : Bottom._windowSize()\n    this.minArea = this.winSize - (this.bound.lower || this.options.maxStartArea || MAX_START_AREA)\n  }\n}\n","import {\n  Bound,\n  DrawerResponseInterface as DRI,\n  Path,\n  WINDOW,\n  ZERO,\n  resolveThreshold\n} from './../../util'\nimport {\n  Service\n} from './../service'\nimport {\n  VectorRectangle\n} from './../vector'\n\nconst THRESHOLD = 'threshold'\nconst BELOW_THRESHOLD = 'belowthreshold'\nconst OPEN = 'open'\nconst CLOSE = 'close'\nconst UNIT = 'px'\nconst MAX_START_AREA = 25\nconst THRESHOLD_VALUE = 0.667\nconst FALSE_TOUCH_START_POINT = 2\n\nexport default class Left {\n  /**\n   * @param {{}} options\n   * an object containing all required properties\n   * @param {Bound} bound a boundary object\n   */\n  constructor(options, bound) {\n    this.options = options\n    this.bound = bound\n    /**\n     * Drawer Element\n     * @type {HTMLElement}\n     */\n    this.element = options.ELEMENT\n    /**\n     * Size of device window\n     *\n     * unused: required in `Right` and `Bottom`\n     * @type {Function}\n     */\n    this._winSize = this.options.sizeOfWindow || Left._windowSize\n    this.winSize = this._winSize()\n    /**\n     * @type {number}\n     */\n    this.width = this.options.SIZE\n    this.unit = this.options.unit || UNIT\n    /**\n     * @type {number}\n     * A maximum area where the draw-start is sensitive\n     * Use set boundary (`bound`) if there's an initial\n     * offset\n     */\n    this.maxArea = this.bound.lower || this.options.maxStartArea || MAX_START_AREA\n\n    /**\n     * A threshold which the `touchmove` signal must attain\n     * before being qualified to stay shown\n     * the threshold should be a value between `0` and `1.0`\n     * @type {number}\n     */\n    this.threshold = this.options.threshold || THRESHOLD_VALUE\n    this.threshold = resolveThreshold(this.threshold)\n\n    // Touch coordinates (Touch Start)\n    this.startX = -1\n    this.startY = -1\n    // Touch coordinates (Touch Move)\n    this.resumeX = -1\n    this.resumeY = -1\n    // Touch coordinates (Touch End) [these may not be important]\n    this.endX = -1\n    this.endY = -1\n\n    /**\n     * A control for scroll. This control prevents\n     * a clash between coordinates dancing between\n     * the (&delta;`X`) coords and (&delta;`Y`) coords.\n     * Utilising the `Rectangle` class to get bounds\n     * and isolate territories\n     * @type {boolean}\n     */\n    this.scrollControlSet = false\n    this.scrollControl = null\n    this.timing = {\n      /**\n       * @type {Date}\n       */\n      start: null,\n      /**\n       * @type {Date}\n       */\n      end: null\n    }\n\n    this._context = this\n  }\n\n  /**\n   * The `touchstart` event handler for the `Left` drawer `class`\n   * @param {TouchEvent} touchEvent an event `object`: An event `object`\n   * representing an `object` of all `properties` related\n   * to the `touchstart` event.\n   * @param {Function} fn - a callback function called when the `start`\n   * event is triggered\n   * @returns {void}\n   */\n  start(touchEvent, fn) {\n    this.timing.start = new Date()\n    this._updateOrientation()\n    const start = touchEvent.changedTouches[0].clientX\n    this.startX = start\n    this.startY = touchEvent.changedTouches[0].clientY\n    /**\n     * The `Drawer`'s `Left` class uses the `CSS property`, `left`\n     * for updating and defining position of the drawn element\n     */\n    const currentPosition = this.element.offsetLeft\n    const bound = this.bound\n    this.positionOnStart = currentPosition\n    const dimension = bound.lower ? `-${bound.upper - bound.lower}${this.unit}` : `-${bound.upper - start}${this.unit}`\n    const displacement = `-${bound.upper - FALSE_TOUCH_START_POINT}${this.unit}`\n\n    if (start >= ZERO && start <= this.maxArea && currentPosition === bound.slack) {\n      const response = {\n        [DRI.position]: currentPosition,\n        [DRI.dimension]: dimension,\n        [DRI.displacement]: displacement\n      }\n      fn.call(this._context, new Service(touchEvent), response, new Path(this.startX, this.startY))\n    }\n  }\n\n  /**\n   * The `touchmove` event handler for the `Left` drawer `class`\n   * @param {TouchEvent} touchEvent an event `object`: An event `object`\n   * representing an `object` of all `properties` related\n   * to the `touchmove` event.\n   * @param {Function} fn - a callback function called when the `move`\n   * event is triggered\n   * @returns {void}\n   */\n  move(touchEvent, fn) {\n    /* eslint complexity: [\"error\", 25] */\n    const resume = touchEvent.changedTouches[0].clientX\n    this.resumeX = resume\n    this.resumeY = touchEvent.changedTouches[0].clientY\n\n    const currentPosition = this.element.offsetLeft\n    const bound = this.bound\n    // const nextAction = this.positionOnStart === ZERO ? CLOSE : OPEN\n    const start = this.startX\n    const width = bound.upper || this.width\n    /**\n     * When the touch doesn't start from the max-width\n     * of the element ignore `start` and use `width`\n     * as starting point.\n     */\n    const virtualStart = start > width ? width : start\n    /**\n     * Dimension for opening. When the drawer is being opened,\n     * the `width` is the max dimension, and the `start` can\n     * only be less than the `width` (from a range of `0` to\n     * `this.maxArea` e.g `0` - `25`), so the current\n     * reading from `resume` is subtracted from the `width` to\n     * get the accurate position to update the drawer with.\n     */\n\n    const dimension = `${-start + resume + this.positionOnStart}${this.unit}`\n    // const dimension = `-${width - bound.lower - resume}${this.unit}`\n    /**\n     * Dimension for closing. When the drawer is being closed,\n     * the `width` is the max dimension and the `start` could\n     * possibly be more than the `width`\n     * or less than the `width`.\n     * To assure an accurate dimension the `virtualStart`\n     * determines whether to use the `width` as starting point\n     * or the actual `start`. If the actual start is more than\n     * `width`, the width becomes the start point else the `start`\n     */\n    const vdimension = `-${virtualStart - resume - this.positionOnStart}${this.unit}`\n    const rect = new VectorRectangle(\n      this.startX,\n      this.startY,\n      this.resumeX,\n      this.resumeY\n    )\n    const isBoundX = rect.greaterWidth\n\n    if (!this.scrollControlSet) {\n      this.scrollControl = isBoundX\n      this.scrollControlSet = !this.scrollControlSet\n    }\n\n    // OPEN LOGIC\n    if (start >= ZERO && (start <= this.maxArea || start <= width + currentPosition) &&\n    currentPosition < ZERO && rect.width < bound.gap && isBoundX &&\n    this.scrollControl && rect.displacementX > ZERO) {\n      const response = {\n        [DRI.position]: currentPosition,\n        [DRI.posOnStart]: this.positionOnStart,\n        [DRI.dimension]: dimension,\n        [DRI.open]: true,\n        [DRI.close]: false\n      }\n      fn.call(this._context, new Service(touchEvent), response, rect)\n    }\n\n    // CLOSE LOGIC\n    if (resume <= width && Math.abs(currentPosition) < bound.gap && rect.width < bound.gap &&\n    isBoundX && this.scrollControl && rect.displacementX < ZERO) {\n      const response = {\n        [DRI.position]: currentPosition,\n        [DRI.posOnStart]: this.positionOnStart,\n        [DRI.dimension]: vdimension,\n        [DRI.close]: true,\n        [DRI.open]: false\n      }\n      fn.call(this._context, new Service(touchEvent), response, rect)\n    }\n  }\n\n  /**\n   * The `touchend` event handler for the `Left` drawer `class`\n   * @param {TouchEvent} touchEvent an event `object`: An event `object`\n   * representing an `object` of all `properties` related\n   * to the `touchend` event.\n   * @param {Function} fn - a callback function called when the `end`\n   * event is triggered\n   * @param {{}} thresholdState - a state object which should be passed\n   * by reference for updating by this method\n   * @returns {void}\n   */\n  end(touchEvent, fn, thresholdState) {\n    this.timing.end = new Date()\n\n    const end = touchEvent.changedTouches[0].clientX\n    this.endX = end\n    this.endY = touchEvent.changedTouches[0].clientY\n\n    const rect = new VectorRectangle(this.startX, this.startY, this.endX, this.endY)\n\n    const start = this.startX\n    const TIMING = this.timing.end.getTime() - this.timing.start.getTime()\n    const threshold = this.threshold\n    const signedOffsetSide = this.element.offsetLeft\n    const bound = this.bound\n    const customBound = new Bound(bound.upper + this.positionOnStart, bound.upper)\n    const nonZero = `${bound.slack}${this.unit}`\n    const zero = `${ZERO}`\n    const width = bound.upper || this.width\n    const offsetSide = Math.abs(signedOffsetSide)\n    let action = OPEN\n    // release the control for another session\n    this.scrollControl = this.scrollControlSet = false // eslint-disable-line no-multi-assign\n\n    const response = {\n      [DRI.position]: signedOffsetSide,\n      [DRI.posOnStart]: this.positionOnStart,\n      rect\n    }\n\n    function getResponse(state, trueForOpen) {\n      if (state === THRESHOLD && trueForOpen || state === BELOW_THRESHOLD && !trueForOpen) {\n        return {\n          [DRI.dimension]: zero,\n          TIMING,\n          [DRI.oppositeDimension]: nonZero,\n          ...response\n        }\n      } else if (state === THRESHOLD && !trueForOpen || state === BELOW_THRESHOLD && trueForOpen) {\n        return {\n          [DRI.dimension]: nonZero,\n          TIMING,\n          [DRI.oppositeDimension]: zero,\n          ...response\n        }\n      }\n      return {}\n    }\n\n    // OPEN LOGIC\n    if (rect.displacementX >= ZERO && (start <= this.maxArea || start <= width + signedOffsetSide)) {\n      if (rect.width >= customBound.gap * resolveThreshold(threshold)) {\n        thresholdState.state = [THRESHOLD, CLOSE]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], true)\n      } else {\n        thresholdState.state = [BELOW_THRESHOLD, CLOSE]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], true)\n      }\n      thresholdState.service = new Service(touchEvent)\n      fn.call(this, action)\n      return\n    }\n\n    // CLOSE LOGIC\n    if (rect.displacementX <= ZERO && this.resumeX <= width) {\n      action = CLOSE\n      if (offsetSide >= width * threshold) {\n        thresholdState.state = [THRESHOLD, OPEN]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], false)\n      } else {\n        thresholdState.state = [BELOW_THRESHOLD, OPEN]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], false)\n      }\n      thresholdState.service = new Service(touchEvent)\n      fn.call(this, action)\n    }\n  }\n\n  setContext(ctx) {\n    this._context = ctx\n    return this\n  }\n\n  static _getStyle(elt, pseudoElt) {\n    return pseudoElt ? WINDOW.getComputedStyle(elt, pseudoElt) : WINDOW.getComputedStyle(elt)\n  }\n\n  static _windowSize() {\n    return WINDOW.screen.width\n  }\n\n  // window size is not needed here; at least not yet\n  // the major purpose of this is to update bound dependents\n  _updateOrientation() {\n    this.winSize = typeof this._winSize === 'function' ? this._winSize() : Left._windowSize()\n    this.minArea = this.bound.lower || this.options.maxStartArea || MAX_START_AREA\n  }\n}\n","import {\n  Bound,\n  DrawerResponseInterface as DRI,\n  Path,\n  WINDOW,\n  ZERO,\n  offsetRight,\n  resolveThreshold\n} from './../../util'\nimport {\n  Service\n} from './../service'\nimport {\n  VectorRectangle\n} from './../vector'\n\nconst THRESHOLD = 'threshold'\nconst BELOW_THRESHOLD = 'belowthreshold'\nconst OPEN = 'open'\nconst CLOSE = 'close'\nconst UNIT = 'px'\nconst MAX_START_AREA = 25\nconst THRESHOLD_VALUE = 0.667\nconst FALSE_TOUCH_START_POINT = 2\n\nexport default class Right {\n  /**\n   * @param {{}} options\n   * an object containing all required properties\n   * @param {Bound} bound a boundary object\n   */\n  constructor(options, bound) {\n    this.options = options\n    this.bound = bound\n    /**\n     * Drawer Element\n     * @type {HTMLElement}\n     */\n    this.element = options.ELEMENT\n    /**\n     * Size of device window\n     * @type {Function}\n     */\n    this._winSize = this.options.sizeOfWindow || Right._windowSize\n    /**\n     * @type {number}\n     */\n    this.winSize = this._winSize()\n    /**\n     * @type {number}\n     */\n    this.width = this.options.SIZE\n    this.unit = this.options.unit || UNIT\n    /**\n     * @type {number}\n     * A minimum area where the draw-start is sensitive\n     */\n    this.minArea = this.winSize - (this.bound.lower || this.options.maxStartArea || MAX_START_AREA)\n\n    /**\n     * A threshold which the `touchmove` signal must attain\n     * before being qualified to stay shown\n     * the threshold should be a value between `0` and `1.0`\n     * @type {number}\n     */\n    this.threshold = this.options.threshold || THRESHOLD_VALUE\n    this.threshold = resolveThreshold(this.threshold)\n\n    // Touch coordinates (Touch Start)\n    this.startX = -1\n    this.startY = -1\n    // Touch coordinates (Touch Move)\n    this.resumeX = -1\n    this.resumeY = -1\n    // Touch coordinates (Touch End) [these may not be important]\n    this.endX = -1\n    this.endY = -1\n\n    /**\n     * A control for scroll. This control prevents\n     * a clash between coordinates dancing between\n     * the (&delta;`X`) coords and (&delta;`Y`) coords.\n     * Utilising the `Rectangle` class to get bounds\n     * and isolate territories\n     * @type {boolean}\n     */\n    this.scrollControlSet = false\n    this.scrollControl = null\n    this.timing = {\n      /**\n       * @type {Date}\n       */\n      start: null,\n      /**\n       * @type {Date}\n       */\n      end: null\n    }\n\n    this._context = this\n  }\n\n  /**\n   * The `touchstart` event handler for the `Left` drawer `class`\n   * @param {TouchEvent} touchEvent an event `object`: An event `object`\n   * representing an `object` of all `properties` related\n   * to the `touchstart` event.\n   * @param {Function} fn - a callback function called when the `start`\n   * event is triggered\n   * @returns {void}\n   */\n  start(touchEvent, fn) {\n    this.timing.start = new Date()\n    this._updateOrientation()\n    const WIN_WIDTH = this.winSize\n    const start = touchEvent.changedTouches[0].clientX\n    this.startX = start\n    this.startY = touchEvent.changedTouches[0].clientY\n    /**\n     * The `Drawer`'s `Right` class uses the `CSS property`, `right`\n     * for updating and defining position of the drawn element\n     */\n    const currentPosition = offsetRight(this.element)\n    const bound = this.bound\n    this.positionOnStart = currentPosition\n    const dimension = bound.lower ? `-${bound.upper - bound.lower}${this.unit}` : `-${bound.upper - (WIN_WIDTH - start)}${this.unit}`\n    const displacement = `-${bound.upper - FALSE_TOUCH_START_POINT}${this.unit}`\n\n    if (start <= WIN_WIDTH && start >= this.minArea && currentPosition === bound.slack) {\n      const response = {\n        [DRI.position]: currentPosition,\n        [DRI.dimension]: dimension,\n        [DRI.displacement]: displacement\n      }\n      fn.call(this._context, new Service(touchEvent), response, new Path(this.startX, this.startY))\n    }\n  }\n\n  /**\n   * The `touchmove` event handler for the `Right` drawer `class`\n   * @param {TouchEvent} touchEvent an event `object`: An event `object`\n   * representing an `object` of all `properties` related\n   * to the `touchmove` event.\n   * @param {Function} fn - a callback function called when the `move`\n   * event is triggered\n   * @returns {void}\n   */\n  move(touchEvent, fn) {\n    /* eslint complexity: [\"error\", 25] */\n    const WIN_WIDTH = this.winSize\n    const FALSE_WIDTH = WIN_WIDTH - this.bound.upper\n    const resume = touchEvent.changedTouches[0].clientX\n    this.resumeX = resume\n    this.resumeY = touchEvent.changedTouches[0].clientY\n\n    const currentPosition = offsetRight(this.element)\n    const bound = this.bound\n    // const nextAction = this.positionOnStart === ZERO ? CLOSE : OPEN\n\n    const start = this.startX\n    // const width = bound.upper || this.width\n    /**\n     * When the touch doesn't start from the max-width\n     * of the element ignore `start` and use `width`\n     * as starting point.\n     */\n    const virtualStart = start < FALSE_WIDTH ? FALSE_WIDTH : start\n\n    const dimension = `${start - resume + this.positionOnStart}${this.unit}`\n    // const dimension = `-${width - bound.lower - (WIN_WIDTH - resume)}${this.unit}`\n\n    /**\n     * Dimension for closing. When the drawer is being closed,\n     * the `width` is the max dimension and the `start` could\n     * possibly be more than the `width`\n     * or less than the `width`.\n     * To assure an accurate dimension the `virtualStart`\n     * determines whether to use the `width` as starting point\n     * or the actual `start`. If the actual start is more than\n     * `width`, the width becomes the start point else the `start`\n     */\n    const vdimension = `-${-virtualStart + resume - this.positionOnStart}${this.unit}`\n    const rect = new VectorRectangle(\n      this.startX,\n      this.startY,\n      this.resumeX,\n      this.resumeY\n    )\n    const isBoundX = rect.greaterWidth\n\n    if (!this.scrollControlSet) {\n      this.scrollControl = isBoundX\n      this.scrollControlSet = !this.scrollControlSet\n    }\n\n    // OPEN LOGIC\n    if (start <= WIN_WIDTH && (start >= this.minArea || start >= FALSE_WIDTH - currentPosition) &&\n    currentPosition < ZERO && rect.width < bound.gap && isBoundX &&\n    this.scrollControl && rect.displacementX < ZERO) {\n      const response = {\n        [DRI.position]: currentPosition,\n        [DRI.posOnStart]: this.positionOnStart,\n        [DRI.dimension]: dimension,\n        [DRI.open]: true,\n        [DRI.close]: false\n      }\n      fn.call(this._context, new Service(touchEvent), response, rect)\n    }\n\n    // CLOSE LOGIC\n    if (resume >= FALSE_WIDTH && Math.abs(currentPosition) < bound.gap && rect.width < bound.gap &&\n    isBoundX && this.scrollControl && rect.displacementX > ZERO) {\n      const response = {\n        [DRI.position]: currentPosition,\n        [DRI.posOnStart]: this.positionOnStart,\n        [DRI.dimension]: vdimension,\n        [DRI.close]: true,\n        [DRI.open]: false\n      }\n      fn.call(this._context, new Service(touchEvent), response, rect)\n    }\n  }\n\n  /**\n   * The `touchend` event handler for the `Right` drawer `class`\n   * @param {TouchEvent} touchEvent an event `object`: An event `object`\n   * representing an `object` of all `properties` related\n   * to the `touchend` event.\n   * @param {Function} fn - a callback function called when the `end`\n   * event is triggered\n   * @param {{}} thresholdState - a state object which should be passed\n   * by reference for updating by this method\n   * @returns {void}\n   */\n  end(touchEvent, fn, thresholdState) {\n    this.timing.end = new Date()\n    const WIN_WIDTH = this.winSize\n    const FALSE_WIDTH = WIN_WIDTH - this.bound.upper\n    const end = touchEvent.changedTouches[0].clientX\n    this.endX = end\n    this.endY = touchEvent.changedTouches[0].clientY\n\n    const rect = new VectorRectangle(this.startX, this.startY, this.endX, this.endY)\n\n    const start = this.startX\n    const TIMING = this.timing.end.getTime() - this.timing.start.getTime()\n    const threshold = this.threshold\n    const signedOffsetSide = offsetRight(this.element)\n    const bound = this.bound\n    const customBound = new Bound(bound.upper + this.positionOnStart, bound.upper)\n    const nonZero = `${bound.slack}${this.unit}`\n    const zero = `${ZERO}`\n    const width = bound.upper || this.width\n    const offsetSide = Math.abs(signedOffsetSide)\n    let action = OPEN\n    // release the control for another session\n    this.scrollControl = this.scrollControlSet = false // eslint-disable-line no-multi-assign\n\n    const response = {\n      [DRI.position]: signedOffsetSide,\n      [DRI.posOnStart]: this.positionOnStart,\n      rect\n    }\n\n    function getResponse(state, trueForOpen) {\n      if (state === THRESHOLD && trueForOpen || state === BELOW_THRESHOLD && !trueForOpen) {\n        return {\n          [DRI.dimension]: zero,\n          TIMING,\n          [DRI.oppositeDimension]: nonZero,\n          ...response\n        }\n      } else if (state === THRESHOLD && !trueForOpen || state === BELOW_THRESHOLD && trueForOpen) {\n        return {\n          [DRI.dimension]: nonZero,\n          TIMING,\n          [DRI.oppositeDimension]: zero,\n          ...response\n        }\n      }\n      return {}\n    }\n\n    // OPEN LOGIC\n    if (rect.displacementX <= ZERO && (start >= this.minArea || start >= FALSE_WIDTH - signedOffsetSide)) {\n      if (rect.width >= customBound.gap * resolveThreshold(threshold)) {\n        thresholdState.state = [THRESHOLD, CLOSE]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], true)\n      } else {\n        thresholdState.state = [BELOW_THRESHOLD, CLOSE]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], true)\n      }\n      thresholdState.service = new Service(touchEvent)\n      fn.call(this, action)\n      return\n    }\n\n    // CLOSE LOGIC\n    if (rect.displacementX >= ZERO && this.resumeX >= FALSE_WIDTH) {\n      action = CLOSE\n      if (offsetSide >= width * threshold) {\n        thresholdState.state = [THRESHOLD, OPEN]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], false)\n      } else {\n        thresholdState.state = [BELOW_THRESHOLD, OPEN]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], false)\n      }\n      thresholdState.service = new Service(touchEvent)\n      fn.call(this, action)\n    }\n  }\n\n  setContext(ctx) {\n    this._context = ctx\n    return this\n  }\n\n  static _getStyle(elt, pseudoElt) {\n    return pseudoElt ? WINDOW.getComputedStyle(elt, pseudoElt) : WINDOW.getComputedStyle(elt)\n  }\n\n  static _windowSize() {\n    return WINDOW.screen.width\n  }\n\n  // no need for `window.onorientationchange`\n  _updateOrientation() {\n    this.winSize = typeof this._winSize === 'function' ? this._winSize() : Right._windowSize()\n    this.minArea = this.winSize - (this.bound.lower || this.options.maxStartArea || MAX_START_AREA)\n  }\n}\n","import {\n  Bound,\n  DrawerResponseInterface as DRI,\n  Path,\n  WINDOW,\n  ZERO,\n  resolveThreshold\n} from './../../util'\nimport {\n  Service\n} from '../service'\nimport {\n  VectorRectangle\n} from './../vector'\n\nconst THRESHOLD = 'threshold'\nconst BELOW_THRESHOLD = 'belowthreshold'\nconst OPEN = 'open'\nconst CLOSE = 'close'\nconst UNIT = 'px'\nconst MAX_START_AREA = 25\nconst THRESHOLD_VALUE = 0.667\nconst FALSE_TOUCH_START_POINT = 2\n\nexport default class Top {\n  /**\n   * @param {{}} options\n   * an object containing all required properties\n   * @param {Bound} bound a boundary object\n   */\n  constructor(options, bound) {\n    this.options = options\n    this.bound = bound\n    /**\n     * Drawer Element\n     * @type {HTMLElement}\n     */\n    this.element = options.ELEMENT\n    /**\n     * Size of device window\n     *\n     * unused: required in `Right` and `Bottom`\n     * @type {Function}\n     */\n    this._winSize = this.options.sizeOfWindow || Top._windowSize\n    this.winSize = this._winSize()\n    /**\n     * @type {number}\n     */\n    this.height = this.options.SIZE\n    this.unit = this.options.unit || UNIT\n    /**\n     * @type {number}\n     * A maximum area where the draw-start is sensitive\n     * Use set boundary (`bound`) if there's an initial\n     * offset\n     */\n    this.maxArea = this.bound.lower || this.options.maxStartArea || MAX_START_AREA\n\n    /**\n     * A threshold which the `touchmove` signal must attain\n     * before being qualified to stay shown\n     * the threshold should be a value between `0` and `1.0`\n     * @type {number}\n     */\n    this.threshold = this.options.threshold || THRESHOLD_VALUE\n    this.threshold = resolveThreshold(this.threshold)\n\n    // Touch coordinates (Touch Start)\n    this.startX = -1\n    this.startY = -1\n    // Touch coordinates (Touch Move)\n    this.resumeX = -1\n    this.resumeY = -1\n    // Touch coordinates (Touch End) [these may not be important]\n    this.endX = -1\n    this.endY = -1\n\n    /**\n     * A control for scroll. This control prevents\n     * a clash between coordinates dancing between\n     * the (&delta;`X`) coords and (&delta;`Y`) coords.\n     * Utilising the `Rectangle` class to get bounds\n     * and isolate territories\n     * @type {boolean}\n     */\n    this.scrollControlSet = false\n    this.scrollControl = null\n    this.timing = {\n      /**\n       * @type {Date}\n       */\n      start: null,\n      /**\n       * @type {Date}\n       */\n      end: null\n    }\n\n    this._context = this\n  }\n\n  /**\n   * The `touchstart` event handler for the `Top` drawer `class`\n   * @param {TouchEvent} touchEvent an event `object`: An event `object`\n   * representing an `object` of all `properties` related\n   * to the `touchstart` event.\n   * @param {Function} fn - a callback function called when the `start`\n   * event is triggered\n   * @returns {void}\n   */\n  start(touchEvent, fn) {\n    this.timing.start = new Date()\n    this._updateOrientation()\n    const start = touchEvent.changedTouches[0].clientY\n    this.startX = touchEvent.changedTouches[0].clientX\n    this.startY = start\n    /**\n     * The `Drawer`'s `Top` class uses the `CSS property`, `top`\n     * for updating and defining position of the drawn element\n     */\n    const currentPosition = this.element.offsetTop\n    const bound = this.bound\n    this.positionOnStart = currentPosition\n    const dimension = bound.lower ? `-${bound.upper - bound.lower}${this.unit}` : `-${bound.upper - start}${this.unit}`\n    const displacement = `-${bound.upper - FALSE_TOUCH_START_POINT}${this.unit}`\n    const maxArea = bound.lower || this.minArea\n\n    if (start >= ZERO && start <= maxArea && currentPosition === bound.slack) {\n      const response = {\n        [DRI.position]: currentPosition,\n        [DRI.dimension]: dimension,\n        [DRI.displacement]: displacement\n      }\n      fn.call(this._context, new Service(touchEvent), response, new Path(this.startX, this.startY))\n    }\n  }\n\n  /**\n   * The `touchmove` event handler for the `Top` drawer `class`\n   * @param {TouchEvent} touchEvent an event `object`: An event `object`\n   * representing an `object` of all `properties` related\n   * to the `touchmove` event.\n   * @param {Function} fn - a callback function called when the `move`\n   * event is triggered\n   * @returns {void}\n   */\n  move(touchEvent, fn) {\n    /* eslint complexity: [\"error\", 25] */\n    const resume = touchEvent.changedTouches[0].clientY\n    this.resumeX = touchEvent.changedTouches[0].clientX\n    this.resumeY = resume\n\n    const currentPosition = this.element.offsetTop\n    const bound = this.bound\n    // const nextAction = this.positionOnStart === ZERO ? CLOSE : OPEN\n\n    const start = this.startX\n    const height = bound.upper || this.height\n    /**\n     * When the touch doesn't start from the max-height\n     * of the element ignore `start` and use `height`\n     * as starting point.\n     */\n    const virtualStart = start > height ? height : start\n    /**\n     * Dimension for opening. When the drawer is being opened,\n     * the `height` is the max dimension, and the `start` can\n     * only be less than the `height` (from a range of `0` to\n     * `this.maxArea` e.g `0` - `25`), so the current\n     * reading from `resume` is subtracted from the `height` to\n     * get the accurate position to update the drawer with.\n     */\n\n    const dimension = `${-start + resume + this.positionOnStart}${this.unit}`\n    // const dimension = `-${height - bound.lower - resume}${this.unit}`\n    /**\n     * Dimension for closing. When the drawer is being closed,\n     * the `height` is the max dimension and the `start` could\n     * possibly be more than the `height`\n     * or less than the `height`.\n     * To assure an accurate dimension the `virtualStart`\n     * determines whether to use the `height` as starting point\n     * or the actual `start`. If the actual start is more than\n     * `height`, the height becomes the start point else the `start`\n     */\n    const vdimension = `-${virtualStart - resume - this.positionOnStart}${this.unit}`\n    const rect = new VectorRectangle(\n      this.startX,\n      this.startY,\n      this.resumeX,\n      this.resumeY\n    )\n    const isBoundY = rect.greaterHeight\n\n    if (!this.scrollControlSet) {\n      this.scrollControl = isBoundY\n      this.scrollControlSet = !this.scrollControlSet\n    }\n\n    // OPEN LOGIC\n    if (start >= ZERO && (start <= this.maxArea || start <= height + currentPosition) &&\n    currentPosition < ZERO && rect.width < bound.gap && isBoundY &&\n    this.scrollControl && rect.displacementY > ZERO) {\n      const response = {\n        [DRI.position]: currentPosition,\n        [DRI.posOnStart]: this.positionOnStart,\n        [DRI.dimension]: dimension,\n        [DRI.open]: true,\n        [DRI.close]: false\n      }\n      fn.call(this._context, new Service(touchEvent), response, rect)\n    }\n\n    // CLOSE LOGIC\n    if (resume <= this.height && Math.abs(currentPosition) < bound.gap && rect.width < bound.gap &&\n    isBoundY && this.scrollControl && rect.displacementY < ZERO) {\n      const response = {\n        [DRI.position]: currentPosition,\n        [DRI.posOnStart]: this.positionOnStart,\n        [DRI.dimension]: vdimension,\n        [DRI.close]: true,\n        [DRI.open]: false\n      }\n      fn.call(this._context, new Service(touchEvent), response, rect)\n    }\n  }\n\n  /**\n   * The `touchend` event handler for the `Top` drawer `class`\n   * @param {TouchEvent} touchEvent an event `object`: An event `object`\n   * representing an `object` of all `properties` related\n   * to the `touchend` event.\n   * @param {Function} fn - a callback function called when the `end`\n   * event is triggered\n   * @param {{}} thresholdState - a state object which should be passed\n   * by reference for updating by this method\n   * @returns {void}\n   */\n  end(touchEvent, fn, thresholdState) {\n    this.timing.end = new Date()\n\n    const end = touchEvent.changedTouches[0].clientY\n    this.endX = touchEvent.changedTouches[0].clientX\n    this.endY = end\n\n    const rect = new VectorRectangle(this.startX, this.startY, this.endX, this.endY)\n\n    const start = this.startY\n    const TIMING = this.timing.end.getTime() - this.timing.start.getTime()\n    const threshold = this.threshold\n    const signedOffsetSide = this.element.offsetTop\n    const bound = this.bound\n    const customBound = new Bound(bound.upper + this.positionOnStart, bound.upper)\n    const nonZero = `${bound.slack}${this.unit}`\n    const zero = `${ZERO}`\n    const height = bound.upper || this.height\n    const offsetSide = Math.abs(signedOffsetSide)\n    let action = OPEN\n    // release the control for another session\n    this.scrollControl = this.scrollControlSet = false // eslint-disable-line no-multi-assign\n\n    const response = {\n      [DRI.position]: signedOffsetSide,\n      [DRI.posOnStart]: this.positionOnStart,\n      rect\n    }\n\n    function getResponse(state, trueForOpen) {\n      if (state === THRESHOLD && trueForOpen || state === BELOW_THRESHOLD && !trueForOpen) {\n        return {\n          [DRI.dimension]: zero,\n          TIMING,\n          [DRI.oppositeDimension]: nonZero,\n          ...response\n        }\n      } else if (state === THRESHOLD && !trueForOpen || state === BELOW_THRESHOLD && trueForOpen) {\n        return {\n          [DRI.dimension]: nonZero,\n          TIMING,\n          [DRI.oppositeDimension]: zero,\n          ...response\n        }\n      }\n      return {}\n    }\n\n    // OPEN LOGIC\n    if (rect.displacementY >= ZERO && (start <= this.maxArea || start <= height + signedOffsetSide)) {\n      if (rect.height >= customBound.gap * resolveThreshold(threshold)) {\n        thresholdState.state = [THRESHOLD, CLOSE]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], true)\n      } else {\n        thresholdState.state = [BELOW_THRESHOLD, CLOSE]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], true)\n      }\n      thresholdState.service = new Service(touchEvent)\n      fn.call(this, action)\n      return\n    }\n\n    // CLOSE LOGIC\n    if (rect.displacementY <= ZERO && this.resumeY <= height) {\n      action = CLOSE\n      if (offsetSide >= height * threshold) {\n        thresholdState.state = [THRESHOLD, OPEN]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], false)\n      } else {\n        thresholdState.state = [BELOW_THRESHOLD, OPEN]\n        thresholdState.stateObj = getResponse(thresholdState.state[0], false)\n      }\n      thresholdState.service = new Service(touchEvent)\n      fn.call(this, action)\n    }\n  }\n\n  setContext(ctx) {\n    this._context = ctx\n    return this\n  }\n\n  static _getStyle(elt, pseudoElt) {\n    return pseudoElt ? WINDOW.getComputedStyle(elt, pseudoElt) : WINDOW.getComputedStyle(elt)\n  }\n\n  static _windowSize() {\n    return WINDOW.screen.height\n  }\n\n  // window size is not need here; at least not yet\n  // the major purpose of this is to update bound dependents\n  _updateOrientation() {\n    this.winSize = typeof this._winSize === 'function' ? this._winSize() : Top._windowSize()\n    this.minArea = this.bound.lower || this.options.maxStartArea || MAX_START_AREA\n  }\n}\n","import Bottom from './bottom'\nimport Left from './left'\nimport Right from './right'\nimport Top from './top'\nimport {\n  WINDOW\n} from '../../util'\n\nconst BELOW_THRESHOLD = 'belowthreshold'\nconst THRESHOLD = 'threshold'\nconst START = 'start'\nconst MOVE = 'move'\nconst END = 'end'\nconst CLASS_TYPE = '[object SnappedDrawer]'\n\nexport default class SnappedDrawer {\n  /**\n   * @param {{}} options an object of configuration options\n   * @param {Bound} bound a boundary object\n   * @param {{}} drawerManager an object that helps manage drawers\n   * especially when more than one drawer service is running\n   */\n  constructor(options, bound, drawerManager) {\n    this._options = options\n    this._drawerManager = drawerManager\n    this._element = options.ELEMENT\n    this._target = options.TARGET\n    this._handlers = null\n    this._direction = options.DIRECTION\n    this._calibration = null\n    this._callbacks = null\n    this._context = this\n    this._id = 0\n    this.events = ['touchstart', 'touchmove', 'touchend']\n\n    this._setCalibration(this._direction, bound)\n  }\n\n  // enum\n  static UP = 0\n  static LEFT = 1\n  static DOWN = 2\n  static RIGHT = 3\n\n  // public\n  /**\n   * Make sure event handlers are registered using `Drawer.on(...)` before\n   * calling `Drawer.activate()`\n   *\n   * @see {@link Drawer#on | Drawer.on}\n   * @returns {void}\n   */\n  activate() {\n    // get registered callbacks or set default\n    const startfn = this._callbacks ? this._callbacks[START] : def\n    const movefn = this._callbacks ? this._callbacks[MOVE] : def\n    const endfn = this._callbacks ? this._callbacks[END] : def\n\n    const startHandler = (touchEvent) => {\n      const activity = this._drawerManager.getRunningActivity()\n      if (this._calibration &&\n        (this._id && activity && activity.id === this._id ||\n          !activity && this._isCoolSignal(this._getSignal(touchEvent)))) {\n        this._calibration.start(touchEvent, startfn)\n      }\n    }\n\n    const moveHandler = (touchEvent) => {\n      const activity = this._drawerManager.getRunningActivity()\n      if (this._calibration && activity && activity.id === this._id) {\n        this._calibration.move(touchEvent, movefn)\n      }\n    }\n\n    const endHandler = (touchEvent) => {\n      const activity = this._drawerManager.getRunningActivity()\n      if (this._calibration && activity && activity.id === this._id) {\n        const state = {}\n        this._calibration.end(touchEvent, endfn, state) // state by Ref\n        this._processThresholdState(state)\n      }\n    }\n\n    this._register(startHandler, moveHandler, endHandler)\n    for (let i = 0; i < this.events.length; i++) {\n      this._target.addEventListener(this.events[i], this._handlers[i])\n    }\n  }\n\n  /**\n   * A method provided by the `Drawer interface` to deactivate the drawer\n   * @returns {void}\n   */\n  deactivate() {\n    for (let i = 0; i < this.events.length; i++) {\n      this._target.removeEventListener(this.events[i], this._handlers[i])\n    }\n    this._register(null)\n  }\n\n  /**\n   * A method used to register callbacks for the `Drawer class` `touchstart`,\n   * `touchmove` and `touchend` event handlers.\n   *\n   * Always call `Drawer.on(...)` before `Drawer.activate()`.\n   * As in:\n   * ```js\n   * const drawer = new Drawer()\n   * drawer.on(event, () => {\n   *  // TODO\n   * }).activate()\n   * ```\n   *\n   * To prevent modifying the context of `this`, the\n   * `drawer.setContext(...)` method should be invoked with an\n   * argument which is the `this` context of the\n   * `calling class` or alternatively using a wrapper function,\n   * then call the main handler method.\n   * ```js\n   * class UseDrawer {\n   *  // CODE\n   *  method() {\n   *    const drawer = new Drawer()\n   *    drawer.on(...)\n   *      .setContext(this)\n   *      .activate()\n   *  }\n   * }\n   * // OR\n   * drawer.on(event, (stateObj) => {\n   *  this.handler.call(this, stateObj)\n   * }).activate()\n   * ```\n   *\n   * Valid event types taken by this method are:\n   * - `start`\n   * - `move`\n   * - `end`\n   * - `threshold`\n   * - `belowthreshold`\n   * @param {string} event The event type as in the above list\n   * @param {Function} fn A function to call when this event triggers\n   * @returns {this} Returns an instance variable of the `Drawer` class\n   */\n  on(event, fn) {\n    this._registerCallbacks(event, fn)\n    return this\n  }\n\n  setContext(ctx) {\n    this._context = ctx\n    this._calibration.setContext(ctx)\n    return this\n  }\n\n  setServiceID(id) {\n    if (typeof id !== 'number') {\n      throw new TypeError('expected `id` to be a unique number')\n    }\n    this._id = id\n  }\n\n  toString() {\n    return CLASS_TYPE\n  }\n\n  _processThresholdState(state) {\n    if (Object.keys(state).length < 1) {\n      return\n    }\n    const {\n      state: stateArray,\n      stateObj,\n      service\n    } = state\n    const {\n      rect\n    } = stateObj\n    this._callbacks[stateArray[0]].call(this._context, service, stateArray, stateObj, rect)\n  }\n\n  _setCalibration(point, bound) {\n    switch (point) {\n      case SnappedDrawer.UP:\n        this._calibration = new Top(this._options, bound)\n        break\n      case SnappedDrawer.LEFT:\n        this._calibration = new Left(this._options, bound)\n        break\n      case SnappedDrawer.DOWN:\n        this._calibration = new Bottom(this._options, bound)\n        break\n      case SnappedDrawer.RIGHT:\n        this._calibration = new Right(this._options, bound)\n        break\n      default:\n        throw RangeError('Direction out of range')\n    }\n  }\n\n  _isCoolSignal(signal) {\n    const size = this._direction === SnappedDrawer.UP || this._direction === SnappedDrawer.DOWN ? WINDOW.screen.height : WINDOW.screen.width\n    switch (this._direction) {\n      case SnappedDrawer.UP:\n      case SnappedDrawer.LEFT:\n        return signal <= size / 2\n      case SnappedDrawer.RIGHT:\n      case SnappedDrawer.DOWN:\n        return signal > size / 2\n      default:\n        return false\n    }\n  }\n\n  _getSignal(emitter) {\n    switch (this._direction) {\n      case SnappedDrawer.UP:\n      case SnappedDrawer.DOWN:\n        return emitter.changedTouches[0].clientY\n      case SnappedDrawer.LEFT:\n      case SnappedDrawer.RIGHT:\n        return emitter.changedTouches[0].clientX\n      default:\n        return null\n    }\n  }\n\n  _registerCallbacks(event, fn) {\n    this._callbacks = this._callbacks || {\n      [START]: def,\n      [MOVE]: def,\n      [END]: def,\n      [THRESHOLD]: def,\n      [BELOW_THRESHOLD]: def\n    }\n    if (event in this._callbacks) {\n      this._callbacks[event] = fn\n    }\n  }\n\n  _register(...handlers) {\n    this._handlers = handlers\n  }\n}\n\nfunction def() {\n  return false\n}\n","import SnappedDrawer from './snapped-drawer'\n\nclass DrawerManagementStore {\n  constructor() {\n    this.activities = []\n  }\n\n  pushActivity(activity) {\n    this.activities.push(activity)\n  }\n\n  getRunningActivity() {\n    return this.activities.find((activity) => activity.isRunning())\n  }\n}\n\nexport default class Drawer {\n  static SnappedDrawer = SnappedDrawer\n  // enum\n  static UP = SnappedDrawer.UP\n  static LEFT = SnappedDrawer.LEFT\n  static DOWN = SnappedDrawer.DOWN\n  static RIGHT = SnappedDrawer.RIGHT\n  static DrawerManagementStore = new DrawerManagementStore()\n}\n","import {\n  css\n} from '../util'\n\nexport class Backdrop {\n  constructor(backdrop) {\n    this.backdrop = backdrop\n  }\n\n  show(time) {\n    css(this.backdrop, {\n      display: 'block',\n      opacity: 1,\n      transition: `opacity linear ${time / 1e3}s`\n    })\n  }\n\n  hide(time) {\n    css(this.backdrop, {\n      opacity: 0,\n      transition: `opacity linear ${time / 1e3}s`\n    })\n    window.setTimeout(() => {\n      css(this.backdrop, {\n        display: 'none'\n      })\n    }, time)\n  }\n\n  setOpacity(val) {\n    css(this.backdrop, {\n      display: 'block',\n      opacity: val,\n      transition: 'none'\n    })\n  }\n}\n","import {\n  Bound,\n  DIRECTIONS,\n  NAVSTATE_EVENTS,\n  NAV_BOX_SHADOW,\n  WINDOW,\n  css,\n  getAttribute,\n  getData\n} from './../util'\nimport Drawer from './../drawer/'\n\nconst ZERO = 0\nconst KILO = 1e3\nconst MIN_TIME_TO_OVERRIDE_BELOWTHRESHOLD = 0.5\nconst MIN_POSITIVE_DISPLACEMENT = 10\nconst MIN_NEGATIVE_DISPLACEMENT = -MIN_POSITIVE_DISPLACEMENT\nconst TRANSITION_STYLE = 'linear'// 'cubic-bezier(0, 0.5, 0, 1)'\nconst EFFECT = 'transition'\nconst OVERFLOW = 'overflow'\nconst TRANS_TIMING = '0.1s'\nconst TRANS_TEMPLATE = `${TRANSITION_STYLE} ${TRANS_TIMING}`\nconst HIDDEN = 'hidden'\nconst SCROLL = 'scroll'\nconst AUTO = 'auto'\nconst HREF = 'href'\nconst HASH_ATTR = `data-${HREF}`\nconst START = 'start'\nconst MOVE = 'move'\nconst THRESHOLD = 'threshold'\nconst BELOW_THRESHOLD = `below${THRESHOLD}`\nconst MIN_SPEED = 100\nconst MAX_SPEED = 500\n\nclass NavDrawer {\n  /**\n   * Creates a new NavDrawer object. Providing the Left and Right\n   * Drawer functionality.\n   * Support for Top and Bottom may come in the future\n   * @throws RangeError\n   * @param {{}} options An options Object to configure the Drawer with\n   * @param {{}} state An activity and service manager\n   */\n  constructor(options, state) {\n    this.options = options\n    this.state = state\n    this.element = this.options.ELEMENT\n    this._body = this.options.BODY\n    this._backdrop = this.options.BACKDROP\n    this.direction = this.options.DIRECTION\n\n    this._checkDirection()\n\n    this.directionString = DIRECTIONS[this.direction]\n    this.bound = this._bound\n\n    const o = {\n      ...options,\n      SIZE: this.elementSize,\n      TARGET: document\n    }\n    this.drawer = new Drawer.SnappedDrawer(o, this.bound, Drawer.DrawerManagementStore)\n    Drawer.DrawerManagementStore.pushActivity(this.state.activity)\n    this.transition = `${this.directionString} ${TRANS_TEMPLATE}`\n  }\n\n  activate() {\n    this.drawer.on(START, this._startHandler)\n      .on(MOVE, this._moveHandler)\n      .on(THRESHOLD, this._threshold)\n      .on(BELOW_THRESHOLD, this._belowThreshold)\n      .setContext(this)\n      .activate()\n    this.drawer.setServiceID(this.state.activity.id)\n    return 0\n  }\n\n  deactivate() {\n    this.drawer.deactivate()\n    return 0\n  }\n\n  get elementSize() {\n    const axis = this.direction\n    if (axis === Drawer.UP || axis === Drawer.DOWN) {\n      return this.element.offsetHeight\n    }\n    return this.element.offsetWidth\n  }\n\n  /**\n   * @returns {Bound} a boundary object: Bound\n   */\n  get _bound() {\n    const upperBound = this.elementSize\n    if (this.direction === Drawer.RIGHT) {\n      const lowerBound = WINDOW.screen.width - this.element.offsetLeft\n      return new Bound(lowerBound, upperBound)\n    }\n    const lowerBound = upperBound + this.element.offsetLeft\n    return new Bound(lowerBound, upperBound)\n  }\n\n  _startHandler(service, response) {\n    service.lock()\n    this.state.activity.run()\n    css(this.element, {\n      [this.directionString]: response.dimension,\n      boxShadow: NAV_BOX_SHADOW[this.directionString],\n      [EFFECT]: this.transition\n    })\n    this._body.style.overflow = HIDDEN\n  }\n\n  _moveHandler(service, response, rectangle) {\n    service.lock()\n    let curPos = this.direction === Drawer.UP || this.direction === Drawer.DOWN ? rectangle.coordsY.y2 : rectangle.coordsX.x2\n    css(this.element, {\n      [this.directionString]: response.dimension,\n      [EFFECT]: 'none',\n      [OVERFLOW]: HIDDEN\n    })\n    if (this.direction === Drawer.RIGHT) {\n      const WIN_SIZE = WINDOW.screen.width\n      curPos = WIN_SIZE - curPos\n      this._backdrop.setOpacity(curPos / this.elementSize)\n      return\n    }\n    this._backdrop.setOpacity(curPos / this.elementSize)\n  }\n\n  _threshold(service, state, stateObj, rect) {\n    service.lock()\n    const isOpen = state[1] === 'open'\n    const options = {\n      stateObj,\n      transition: `${this.directionString} ${TRANSITION_STYLE} ${this._calcSpeed(stateObj.TIMING, rect.width) / KILO}s`\n    }\n    if (isOpen) {\n      this._hide(options)\n    } else {\n      this._show(options)\n    }\n  }\n\n  _belowThreshold(service, state, stateObj, rect) {\n    service.lock()\n    const isClosed = state[1] !== 'open'\n    const overallEventTime = stateObj.TIMING\n    const MTTOB = MIN_TIME_TO_OVERRIDE_BELOWTHRESHOLD\n    const MPD = MIN_POSITIVE_DISPLACEMENT\n    const MND = MIN_NEGATIVE_DISPLACEMENT\n    const displacement = this.direction === Drawer.UP || this.direction === Drawer.DOWN\n      ? rect.displacementY : rect.displacementX\n    const options = {\n      stateObj,\n      transition: `${this.directionString} ${TRANSITION_STYLE} ${this._calcSpeed(stateObj.TIMING, rect.width) / KILO}s`\n    }\n    let LOGIC\n    if (this.direction === Drawer.LEFT && isClosed || this.direction === Drawer.RIGHT && !isClosed) {\n      LOGIC =  displacement > ZERO && displacement >= MPD && rect.greaterWidth\n    } else {\n      LOGIC = displacement < ZERO && displacement <= MND && rect.greaterWidth\n    }\n\n    if (overallEventTime / KILO < MTTOB) {\n      if (LOGIC) {\n        this._overrideBelowThresh(!isClosed, options)\n      } else {\n        if (isClosed) {\n          // Close it. Can't override\n          this._hide(options)\n          return\n        }\n        // Open it. Can't override. Not enough displacement\n        this._show(options)\n      }\n    } else {\n      if (isClosed) {\n        // close it\n        this._hide(options)\n        return\n      }\n      // open it\n      this._show(options)\n    }\n  }\n\n  _show(options) {\n    this._showPrep(options)\n    this.element.style[this.directionString] = options.stateObj.dimension\n  }\n\n  _hide(options) {\n    this._hidePrep(options)\n    this.element.style[this.directionString] = options.stateObj.dimension\n  }\n\n  _overrideBelowThresh(isOpen, options) {\n    if (isOpen) {\n      this._hidePrep(options)\n      this.element.style[this.directionString] = options.stateObj.oppositeDimension\n    } else {\n      this._showPrep(options)\n      this.element.style[this.directionString] = options.stateObj.oppositeDimension\n    }\n  }\n\n  _hidePrep(options) {\n    this.state.activity.derun()\n    this._body.style.overflow = SCROLL\n    this._backdrop.hide(this.options.TRANSITION)\n    css(this.element, {\n      [EFFECT]: options.transition,\n      [OVERFLOW]: AUTO\n    })\n    if (!this.bound.lower) {\n      this.element.style.boxShadow = 'none'\n    }\n    this._setState('close')\n    // callback for when nav is hidden\n    if (this.state.isRegisteredEvent(NAVSTATE_EVENTS.hide)) {\n      this.state.getStateEventHandler(NAVSTATE_EVENTS.hide)()\n    }\n  }\n\n  _showPrep(options) {\n    const buttonHash = getAttribute(this.options.INIT_ELEM, HREF) || getData(this.options.INIT_ELEM, HASH_ATTR)\n    if (buttonHash) {\n      WINDOW.location.hash = buttonHash\n    }\n    this._body.style.overflow = HIDDEN\n    this._backdrop.show(this.options.TRANSITION)\n    css(this.element, {\n      [EFFECT]: options.transition,\n      [OVERFLOW]: AUTO\n    })\n    this._setState('open')\n    // callback for when nav is shown\n    if (this.state.isRegisteredEvent(NAVSTATE_EVENTS.show)) {\n      this.state.getStateEventHandler(NAVSTATE_EVENTS.show)()\n    }\n  }\n\n  _calcSpeed(time, distance) {\n    const distanceRemain = this.elementSize - distance\n    if (~Math.sign(distanceRemain)) {\n      let newTime = distanceRemain * time / distance\n      if (newTime > MAX_SPEED) {\n        newTime = MAX_SPEED\n      } else if (newTime < MIN_SPEED) {\n        newTime = MIN_SPEED\n      }\n      return newTime\n    }\n    return 0\n  }\n\n  _checkDirection() {\n    if (this.direction !== Drawer.LEFT && this.direction !== Drawer.RIGHT) {\n      throw new RangeError('Direction out of range')\n    }\n  }\n\n  _setState(mode) {\n    switch (mode) {\n      case 'open':\n        this.state.activity.run()\n        break\n      case 'close':\n        this.state.activity.derun()\n        break\n      default:\n        throw new Error('this should never happen')\n    }\n  }\n}\n\nexport default NavDrawer\n","import {\n  NAVSTATE_EVENTS,\n  NAV_BOX_SHADOW,\n  WINDOW,\n  ZERO,\n  css,\n  getAttribute,\n  getData\n} from './../util'\n\nconst TRANSITION_STYLE = 'cubic-bezier(0, 0.5, 0, 1)'\nconst EFFECT = 'transition'\nconst TRANS_END = 'transitionend'\n\nclass NavService {\n  constructor(options, state) {\n    this.options = options\n    this.state = state\n    this.nav = options.ELEMENT\n    this.button = options.INIT_ELEM\n    this.body = options.BODY\n    this.backdrop = options.BACKDROP\n    this.backdropElement = this.backdrop.backdrop\n    this.event = 'click'\n    this.direction = options.DIRECTION\n    this.width = this.nav.offsetWidth\n    this.transTime = options.TRANSITION / 1e3\n    this.transition = `${this.direction} ${TRANSITION_STYLE} ${this.transTime}s`\n    // state of the nav, whether open or close\n    this.alive = false\n    // diff. btw. event triggered from Drawer class and on here\n    /**\n     * @private\n     */\n    this._closeInvoked = false\n    /**\n     * @readonly\n     * @private\n     */\n    this._initialState = NavService.css(this.nav, this.direction)\n    this._handlers = null\n  }\n\n  activate() {\n    const ClickHandler = (mouseEvent) => {\n      this.handler(mouseEvent)\n    }\n    const BackdropHandler = () => {\n      this._close()\n    }\n    const TransitionHandler = () => {\n      if (!this.alive && this._closeInvoked) {\n        this._cleanShadow()\n        this._closeInvoked = false\n      }\n    }\n    this._register({\n      ClickHandler,\n      BackdropHandler,\n      TransitionHandler\n    })\n\n    this.button.addEventListener(this.event, this._handlers.ClickHandler)\n    this.backdropElement.addEventListener(this.event, this._handlers.BackdropHandler)\n    if (this._initialState === `-${this._width('px')}`) {\n      this.nav.addEventListener(TRANS_END, this._handlers.TransitionHandler)\n    }\n    return 0\n  }\n\n  deactivate() {\n    throw new ReferenceError('cannot deactivate a default service. This service must be kept running')\n  }\n\n  forceDeactivate() {\n    this.button.removeEventListener(this.event, this._handlers.ClickHandler)\n    this.backdropElement.removeEventListener(this.event, this._handlers.BackdropHandler)\n    if (this._initialState === `-${this._width('px')}`) {\n      this.nav.removeEventListener(TRANS_END, this._handlers.TransitionHandler)\n    }\n    this._register(null)\n  }\n\n  handler(mouseEvent) {\n    mouseEvent.preventDefault()\n    const state = NavService._toNum(NavService.css(this.nav, this.direction))\n    if (state < ZERO) {\n      const buttonHash = getAttribute(this.button, 'href') || getData(this.button, 'data-href')\n      if (buttonHash) {\n        WINDOW.location.hash = buttonHash\n      }\n      this._open()\n    } else {\n      this._close()\n    }\n  }\n\n  static css(el, property, style) {\n    return css(el, property, style)\n  }\n\n  static _toNum(val) {\n    val = val.replace(/[^\\d]*$/, '')\n    return /\\.(?=\\d)/.test(val) ? Math.round(parseFloat(val)) : parseInt(val, 10)\n  }\n\n  _width(unit) {\n    unit = unit || ''\n    return this.width + unit\n  }\n\n  _register(handler) {\n    this._handlers = handler\n  }\n\n  _open() {\n    const style = {\n      [this.direction]: ZERO,\n      [EFFECT]: this.transition,\n      boxShadow: NAV_BOX_SHADOW[this.direction]\n    }\n    NavService.css(this.nav, style)\n    this.backdrop.show(this.options.TRANSITION)\n    NavService.css(this.body, 'overflow', 'hidden')\n    // callback for when nav is shown\n    if (this.state.isRegisteredEvent(NAVSTATE_EVENTS.show)) {\n      this.state.getStateEventHandler(NAVSTATE_EVENTS.show)()\n    }\n    this.alive = true\n    this.state.activity.run()\n  }\n\n  _close() {\n    const style = {\n      [this.direction]: this._initialState,\n      [EFFECT]: this.transition\n      // don't clean shadow here\n      // it's transitioning\n    }\n    NavService.css(this.nav, style)\n    this.backdrop.hide(this.options.TRANSITION)\n    NavService.css(this.body, 'overflow', 'initial')\n    // callback for when nav is hidden\n    if (this.state.isRegisteredEvent(NAVSTATE_EVENTS.hide)) {\n      this.state.getStateEventHandler(NAVSTATE_EVENTS.hide)()\n    }\n    this.alive = false\n    this._closeInvoked = true\n    this.state.activity.derun()\n  }\n\n  _cleanShadow() {\n    NavService.css(this.nav, 'boxShadow', 'none')\n  }\n}\n\nexport default NavService\n","import {\n  WINDOW,\n  getAttribute,\n  getData\n} from '../util'\n\nclass PopService {\n  constructor(parentService, options, state) {\n    this.options = options\n    this.state = state\n    this.parentService = parentService\n    this.button = options.INIT_ELEM\n    this.event = 'hashchange'\n    this.handler = null\n  }\n\n  activate() {\n    const handler = (hashChangeEvent) => {\n      this._hashchange(hashChangeEvent)\n    }\n    this._register(handler)\n    WINDOW.addEventListener(this.event, this.handler, true)\n    return 0\n  }\n\n  deactivate() {\n    WINDOW.removeEventListener(this.event, this.handler, true)\n    this._register(null)\n    return 0\n  }\n\n  /**\n   * @param {HashChangeEvent} hashChangeEvent Event object\n   * @returns {void}\n   */\n  _hashchange(hashChangeEvent) {\n    const oldHash = PopService._getHash(hashChangeEvent.oldURL)\n    if (oldHash === (getAttribute(this.button, 'href') ||\n    getData(this.button, 'data-href')) &&\n    this.state.activity.isRunning()) {\n      hashChangeEvent.stopImmediatePropagation()\n      this.parentService._close()\n    }\n  }\n\n  _register(handler) {\n    this.handler = handler\n  }\n\n  static _getHash(uri) {\n    let hash = uri\n    const indexOfHash = hash.lastIndexOf('#')\n    hash = indexOfHash !== -1 ? hash.slice(indexOfHash).replace(/(?:[^\\w\\d-]+)$/) : null\n    return hash\n  }\n}\n\nexport default PopService\n","const EventInterface = {\n  SHOW: 'show',\n  HIDE: 'hide'\n}\n\nexport default class State {\n  constructor(activity) {\n    this.activity = activity // activity manager\n    this._stateEventRegistry = {\n      [EventInterface.SHOW]: null,\n      [EventInterface.HIDE]: null\n    }\n  }\n\n  set onshow(val) {\n    if (typeof val !== 'function') {\n      throw new TypeError('value is not a callable type')\n    }\n    this._stateEventRegistry.show = val\n    return true\n  }\n\n  set onhide(val) {\n    if (typeof val !== 'function') {\n      throw new TypeError('value is not a callable type')\n    }\n    this._stateEventRegistry.hide = val\n    return true\n  }\n\n  getStateEventHandler(type) {\n    if (Object.values(EventInterface).indexOf(type) !== -1) {\n      return this._stateEventRegistry[type]\n    }\n    throw new Error('unknown event type')\n  }\n\n  isRegisteredEvent(type) {\n    return typeof this._stateEventRegistry[type] === 'function'\n  }\n}\n","import {\n  $,\n  ActivityManager,\n  DIRECTIONS,\n  NAVSTATE_EVENTS,\n  WINDOW,\n  css,\n  getData\n} from './../util'\nimport {\n  Backdrop\n} from './backdrop'\nimport NavDrawer from './drawer'\nimport NavService from './navservice'\nimport PopService from './popservice'\nimport State from './state'\n\nconst BACKDROP = 'backdrop'\nconst MEDIA_DRAW = 'data-max-width'\nconst CLASS_TYPE = '[object NavCard]'\nconst NAME = 'Nav'\nconst NAV = WINDOW[NAME] || null\n\nclass NavCard {\n  constructor(src, dest) {\n    /**\n     * Covert Backdrop\n     * ----------------\n     * Just incase `options.backdrop = false`\n     * prevents multiple `if` statements\n     * so we don't have to check whether\n     * backdrop is enabled anytime we want to access it.\n     *\n     * Insert into DOM only:\n     * when `options.backdrop = true`\n     * `options.backdropClass` is undefined\n     */\n    this.backdrop = document.createElement('div')\n    this.backdrop.className = BACKDROP\n    css(this.backdrop, {\n      background: 'rgba(0,0,0,.4)',\n      height: '100%',\n      width: '100%',\n      display: 'none',\n      position: 'fixed',\n      top: 0,\n      left: 0\n    })\n    this.src = src\n    this.dest = dest\n    this.body = document.body\n    this.Drawer = null\n    this.SheetService = null\n    this.PopService = null\n    this._Activity = new ActivityManager(this)\n    this.State = new State(this._Activity)\n  }\n\n  static defaultConfig = {\n    transition: 500,\n    direction: -1,\n    useBackdrop: false,\n    backdrop: null,\n    dest: null,\n    scrollableContainer: null,\n    maxStartArea: 25,\n    threshold: 1 / 2,\n    unit: 'px',\n    CustomDrawer: null\n  }\n\n  static SERVICES = {\n    Default: 0x20,\n    Drawer: 0x40,\n    Pop: 0x80\n  }\n\n  setup(options) {\n    if (!this.src) {\n      throw new TypeError(\n        `expected ${NAME} to be constructed with at least 'src' argument:\n        expected 'src' to be selector string or HTMLElement.\n          constructor(src: string | HTMLElement, dest?: string | HTMLElement)`\n      )\n    }\n\n    const opts = typeof Object.assign === 'function' ? Object.assign({}, NavCard.defaultConfig) : {\n      ...NavCard.defaultConfig\n    }\n\n    if (options && typeof options === 'object') {\n      for (const prop of Object.keys(options)) {\n        if (Object.prototype.hasOwnProperty.call(opts, prop)) {\n          opts[prop] = options[prop]\n        } else {\n          continue\n        }\n      }\n    }\n\n    this.dest = this.dest ? this.dest : opts.dest\n\n    const srcEl = this.src instanceof HTMLElement ? this.src : $(this.src)\n    const destEl = this.dest instanceof HTMLElement ? this.dest : $(this.dest)\n    let maxWidth  = getData(destEl, MEDIA_DRAW)\n\n    if (opts.useBackdrop) {\n      const backdropclass = opts.backdrop || false\n      // if `opts.useBackdrop` and no `backdrop` given\n      // append a custom backdrop\n      if (!backdropclass) {\n        destEl.insertAdjacentElement('beforeBegin', this.backdrop)\n      } else if (typeof backdropclass === 'string') {\n        // check if backdropclass is normal string or css class selector\n        const backdrop =  /^\\./.test(backdropclass) ? backdropclass : `.${backdropclass}`\n        this.backdrop = $(backdrop)\n      } else if (backdropclass instanceof HTMLElement) {\n        this.backdrop = backdropclass\n      } else {\n        throw new TypeError('expected \\'options.backdrop\\' to be a selector string or HTMLElement.')\n      }\n    }\n\n    maxWidth = /px$/.test(maxWidth) ? maxWidth : `${maxWidth}px`\n    const defaultOptions = {\n      ELEMENT: destEl,\n      INIT_ELEM: srcEl,\n      BACKDROP: new Backdrop(this.backdrop),\n      BODY: this.body,\n      TRANSITION: opts.transition,\n      DIRECTION: DIRECTIONS[opts.direction],\n      unit: opts.unit\n    }\n    const drawerOptions = {\n      ...defaultOptions,\n      MAX_WIDTH: maxWidth,\n      DIRECTION: opts.direction,\n      maxStartArea: opts.maxStartArea,\n      threshold: opts.threshold,\n      scrollableContainer: opts.scrollableContainer,\n      CustomDrawer: opts.CustomDrawer\n    }\n    const hashOptions = {\n      INIT_ELEM: defaultOptions.INIT_ELEM\n    }\n\n    return new NavMountWorker(this, {\n      defaultOptions,\n      drawerOptions,\n      hashOptions\n    })\n  }\n\n  terminate(service) {\n    service |= 0\n    if (service & NavCard.SERVICES.Default && this.SheetService instanceof NavService) {\n      this.SheetService.deactivate()\n    }\n    if (service & NavCard.SERVICES.Drawer && this.Drawer instanceof NavDrawer) {\n      this.Drawer.deactivate()\n    }\n    if (service & NavCard.SERVICES.Hash && this.PopService instanceof PopService) {\n      this.PopService.deactivate()\n    }\n    if (!service) {\n      throw new Error('a service id is required')\n    }\n  }\n\n  toString() {\n    return CLASS_TYPE\n  }\n\n  static namespace(name) {\n    WINDOW[name] = WINDOW[name] || {}\n    WINDOW[name][NAME] = NavCard\n    WINDOW[NAME] = NAV\n  }\n\n  _drawerAPI(options) {\n    const {\n      CustomDrawer\n    } = options\n    this.Drawer = CustomDrawer && typeof CustomDrawer === 'object' ? new CustomDrawer(options, this.State) : new NavDrawer(options, this.State)\n    return {\n      activate: () => this.Drawer.activate(),\n      deactivate: () => this.Drawer.deactivate()\n    }\n  }\n\n  _hashAPI(options) {\n    this.PopService = new PopService(this.SheetService, options, this.State)\n    return {\n      activate: () => this.PopService.activate(),\n      deactivate: () => this.PopService.deactivate()\n    }\n  }\n\n  _defaultAPI(options) {\n    this.SheetService = new NavService(options, this.State)\n    return {\n      activate: () => this.SheetService.activate(),\n      deactivate: () => this.SheetService.deactivate()\n    }\n  }\n}\n\nclass NavMountWorker {\n  constructor(borrowedContext, options) {\n    this.$this = borrowedContext\n    this.options = options\n  }\n\n  mount() {\n    const DEFAULT_ACTIVE = !this.$this._defaultAPI(this.options.defaultOptions).activate()\n    const DRAWER_ACTIVE = !this.$this._drawerAPI(this.options.drawerOptions).activate()\n    const HASH_ACTIVE = !this.$this._hashAPI(this.options.hashOptions).activate()\n    return new Promise((resolve, reject) => {\n      if (!(DEFAULT_ACTIVE && DRAWER_ACTIVE && HASH_ACTIVE)) {\n        reject(new Error('one or more services could not activate'))\n        return\n      }\n      resolve(new NavStateEvent(this.$this, this.$this.State))\n    })\n  }\n\n  unmount() {\n    this.$this.SheetService.forceDeactivate()\n    this.$this.Drawer.deactivate()\n    this.$this.PopService.deactivate()\n  }\n\n  toString() {\n    return '[object NavMountWorker]'\n  }\n}\n\nclass NavStateEvent {\n  constructor($this, state) {\n    this.events = [NAVSTATE_EVENTS.show, NAVSTATE_EVENTS.hide]\n    this.$this = $this\n    this._State = state\n  }\n\n  on(event, handle = () => false) {\n    if (!(this.events.indexOf(event) + 1)) {\n      throw new Error(`unknown event '${event}'`)\n    }\n    this._State[`on${event}`] = handle.bind(this.$this)\n  }\n\n  off(event) {\n    if (!(this.events.indexOf(event) + 1)) {\n      throw new Error(`unknown event '${event}'`)\n    }\n    this._State[`on${event}`] = null\n  }\n}\n\nexport default NavCard\n","import {\n  Bound,\n  DIRECTIONS,\n  NAVSTATE_EVENTS,\n  NAV_BOX_SHADOW,\n  WINDOW,\n  css,\n  getAttribute,\n  getData,\n  resolveThreshold\n} from './../util'\nimport Drawer from './../drawer/'\n\nconst ZERO = 0\nconst KILO = 1e3\nconst MIN_TIME_TO_OVERRIDE_BELOWTHRESHOLD = 0.1\nconst MIN_POSITIVE_DISPLACEMENT = 15\nconst MIN_NEGATIVE_DISPLACEMENT = -MIN_POSITIVE_DISPLACEMENT\nconst TRANSITION_STYLE = 'linear'\nconst EFFECT = 'transition'\nconst OVERFLOW = 'overflow'\nconst TRANS_TIMING = '0.1s'\nconst TRANS_TEMPLATE = `${TRANSITION_STYLE} ${TRANS_TIMING}`\nconst HIDDEN = 'hidden'\nconst SCROLL = 'scroll'\nconst AUTO = 'auto'\nconst HREF = 'href'\nconst HASH_ATTR = `data-${HREF}`\nconst START = 'start'\nconst MOVE = 'move'\nconst THRESHOLD = 'threshold'\nconst BELOW_THRESHOLD = `below${THRESHOLD}`\nconst MAX_TIME = KILO\nconst MAX_SPEED = 500\nconst MarkIndex = {\n  high: 'high',\n  mid: 'mid',\n  low: 'low'\n}\n\nclass SheetDrawer {\n  /**\n   * Creates a new SheetDrawer object. Providing the Top and Bottom\n   * Drawer functionality\n   * @throws RangeError\n   * @param {{}} options An options Object to configure the Drawer with\n   * @param {State} state An activity and service manager\n   */\n  constructor(options, state) {\n    this.options = options\n    this.state = state\n    this.element = this.options.ELEMENT\n    this._body = this.options.BODY\n    this.backdrop = this.options.BACKDROP\n    this.direction = this.options.DIRECTION\n    this._scCheck = this.options.scrollableContainer\n    this._sc = this._scCheck || document.createElement('div')\n\n    this._checkDirection()\n\n    this.directionString = DIRECTIONS[this.direction]\n    this.bound = this._bound\n    this._oldbound = null\n\n    const o = {\n      ...options,\n      SIZE: this.elementSize,\n      TARGET: document\n    }\n    this.drawer = new Drawer.SnappedDrawer(o, this.bound, Drawer.DrawerManagementStore)\n    Drawer.DrawerManagementStore.pushActivity(this.state.activity)\n    this.transition = `${this.directionString} ${TRANS_TEMPLATE}`\n    this.marks = {\n      [MarkIndex.high]: ZERO,\n      [MarkIndex.mid]: this.bound.slack * resolveThreshold(options.threshold),\n      [MarkIndex.low]: document.documentElement.clientHeight - this.element.offsetTop - this.elementSize\n    }\n    this._Control = {\n      touchMoveExited: false,\n      lastMetredPos: 0\n    }\n  }\n\n  activate() {\n    this.drawer.on(START, this._startHandler)\n      .on(MOVE, this._moveHandler)\n      .on(THRESHOLD, this._threshold)\n      .on(BELOW_THRESHOLD, this._belowThreshold)\n      .setContext(this)\n      .activate()\n    this.drawer.setServiceID(this.state.activity.id)\n    return 0\n  }\n\n  deactivate() {\n    this.drawer.deactivate()\n    return 0\n  }\n\n  get elementSize() {\n    return this.element.offsetHeight\n  }\n\n  get _bound() {\n    const upperBound = this.elementSize\n    if (this.direction === Drawer.DOWN) {\n      // get `element.offsetBottom`\n      const lowerBound = WINDOW.screen.height - this.element.offsetTop\n      return new Bound(lowerBound, upperBound)\n    }\n    const lowerBound = upperBound + this.element.offsetTop\n    return new Bound(lowerBound, upperBound)\n  }\n\n  _startHandler(service, response) {\n    service.lock()\n    this.state.activity.run()\n    css(this.element, {\n      [this.directionString]: !this.bound.lower ? response.dimension : null,\n      boxShadow: NAV_BOX_SHADOW[this.directionString],\n      [EFFECT]: this.transition\n    })\n    this._body.style.overflow = HIDDEN\n  }\n\n  _moveHandler(service, response, rectangle) {\n    service.lock()\n    const WIN_SIZE = WINDOW.screen.height\n    let curPos = rectangle.coordsY.y2\n    if (response.posOnStart === this.marks[MarkIndex.high] && (this._scCheck && this._sc.scrollTop !== ZERO || !this._scCheck)) {\n      this._Control.touchMoveExited = true\n      this._Control.lastMetredPos = curPos\n      return\n    }\n    this._Control.touchMoveExited = false\n    const customDimension = this.direction === Drawer.DOWN ? this._Control.lastMetredPos - curPos + response.posOnStart : -this._Control.lastMetredPos + curPos + response.posOnStart\n    css(this.element, {\n      [this.directionString]: response.dimension,\n      [EFFECT]: 'none',\n      [OVERFLOW]: HIDDEN\n    })\n    css(this._sc, OVERFLOW, HIDDEN)\n\n    if (response.posOnStart === this.marks[MarkIndex.high] && response.closing) {\n      css(this.element, this.directionString, SheetDrawer._toUnit(customDimension, this.options.unit))\n    }\n    if (Math.round(response.posOnStart) === Math.round(this.marks[MarkIndex.mid]) && response.opening && this.direction === Drawer.DOWN\n    ) {\n      this._sc.scrollTo(0, -rectangle.displacementY)\n    }\n    if (this.direction === Drawer.DOWN) {\n      curPos = WIN_SIZE - curPos\n    }\n    this.backdrop.setOpacity(curPos / this.elementSize)\n  }\n\n  _threshold(service, state, stateObj) {\n    service.lock()\n    const isOpen = state[1] === 'open'\n    const options = {\n      stateObj,\n      transition: `${this.directionString} ease ${this._calcSpeed(stateObj.TIMING) / KILO}s`\n    }\n    if (isOpen) {\n      this._hide(options)\n    } else {\n      this._show(options)\n    }\n  }\n\n  _belowThreshold(service, state, stateObj, rect) {\n    service.lock()\n    const isClosed = state[1] !== 'open'\n    const overallEventTime = stateObj.TIMING\n    const MTTOB = MIN_TIME_TO_OVERRIDE_BELOWTHRESHOLD\n    const MPD = MIN_POSITIVE_DISPLACEMENT\n    const MND = MIN_NEGATIVE_DISPLACEMENT\n    const displacement = rect.displacementY\n    const options = {\n      rect,\n      stateObj,\n      transition: `${this.directionString} ease ${this._calcSpeed(stateObj.TIMING) / KILO}s`\n    }\n    const {\n      position\n    } = stateObj\n    const minForwardVelocity = MPD / MTTOB // pixel/second: pps\n    const minBackwardVelocity = MND / MTTOB // pps\n    const velocity = displacement / (overallEventTime / KILO)\n    const LOGIC = this.direction === Drawer.UP && isClosed ||\n    this.direction === Drawer.DOWN && !isClosed\n      ? velocity > minForwardVelocity && rect.greaterHeight\n      : velocity < minBackwardVelocity && rect.greaterHeight\n\n    if (LOGIC) {\n      this._overrideBelowThresh(!isClosed, options)\n      return\n    }\n    if (isClosed) {\n      this.element.style[this.directionString] = SheetDrawer._toUnit(\n        position >= this.marks[MarkIndex.mid] ? (this._halfHidePrep(options), this.marks[MarkIndex.mid]) : (this._hidePrep(options), this.marks[MarkIndex.low]),\n        this.options.unit\n      )\n    } else {\n      this._showPrep(options)\n      this.element.style[this.directionString] = SheetDrawer._toUnit(\n        position >= this.marks[MarkIndex.mid] ? this.marks[MarkIndex.mid] : this.marks[MarkIndex.high],\n        this.options.unit\n      )\n    }\n  }\n\n  _show(options) {\n    if (this._Control.touchMoveExited) {\n      this._Control.touchMoveExited = false\n      return\n    }\n    css(this._sc, OVERFLOW, SCROLL)\n    this._showPrep(options)\n    this.element.style[this.directionString] = SheetDrawer._toUnit(this.marks[MarkIndex.high], this.options.unit)\n  }\n\n  _hide(options) {\n    if (this._Control.touchMoveExited) {\n      this._Control.touchMoveExited = false\n      return\n    }\n    this._hidePrep(options)\n    this.element.style[this.directionString] = SheetDrawer._toUnit(this.marks[MarkIndex.low], this.options.unit)\n  }\n\n  _overrideBelowThresh(isOpen, options) {\n    const {\n      oppositeDimension,\n      position\n    } = options.stateObj\n    const isDownDrawer = this.direction === Drawer.DOWN\n    if (isOpen) {\n      if (this._Control.touchMoveExited) {\n        this._Control.touchMoveExited = false\n        return\n      }\n      this.element.style[this.directionString] = SheetDrawer._toUnit(\n        position >= this.marks[MarkIndex.mid] ? this.marks[MarkIndex.mid] : this.marks[MarkIndex.low],\n        this.options.unit\n      )\n      this._halfHidePrep(options)\n    } else {\n      const halfDimension = SheetDrawer._toUnit(this.marks[MarkIndex.mid], this.options.unit)\n      this._showPrep(options)\n      this.element.style[this.directionString] = isDownDrawer ? halfDimension : oppositeDimension\n    }\n  }\n\n  _halfHidePrep(options) {\n    this._body.style.overflow = HIDDEN\n    css(this.element, {\n      [EFFECT]: options.transition,\n      [OVERFLOW]: AUTO\n    })\n  }\n\n  _hidePrep(options) {\n    this._body.style.overflow = SCROLL\n    this.backdrop.hide(this.options.TRANSITION)\n    css(this.element, {\n      [EFFECT]: options.transition,\n      [OVERFLOW]: AUTO\n    })\n    if (!this.bound.lower) {\n      this.element.style.boxShadow = 'none'\n    }\n    this._setState('close')\n    // callback for when nav is hidden\n    if (this.state.isRegisteredEvent(NAVSTATE_EVENTS.hide)) {\n      this.state.getStateEventHandler(NAVSTATE_EVENTS.hide)()\n    }\n  }\n\n  _showPrep(options) {\n    const buttonHash = getAttribute(this.options.INIT_ELEM, HREF) || getData(this.options.INIT_ELEM, HASH_ATTR)\n    if (buttonHash) {\n      WINDOW.location.hash = buttonHash\n    }\n    this._body.style.overflow = options.bodyOverflow || HIDDEN\n    this.backdrop.show(this.options.TRANSITION)\n    css(this.element, {\n      [EFFECT]: options.transition,\n      [OVERFLOW]: AUTO\n    })\n    this._setState('open')\n    // callback for when nav is shown\n    if (this.state.isRegisteredEvent(NAVSTATE_EVENTS.show)) {\n      this.state.getStateEventHandler(NAVSTATE_EVENTS.show)()\n    }\n  }\n\n  _calcSpeed(time) {\n    if (time >= MAX_TIME) {\n      return MAX_SPEED\n    }\n    const percent = 100\n    const percentage = time / MAX_TIME * percent\n    return percentage / percent * MAX_SPEED\n  }\n\n  _checkDirection() {\n    if (this.direction !== Drawer.UP && this.direction !== Drawer.DOWN) {\n      throw new RangeError('Direction out of range')\n    }\n  }\n\n  _setState(mode) {\n    switch (mode) {\n      case 'open':\n        this.state.activity.run()\n        break\n      case 'close':\n        this.state.activity.derun()\n        break\n      default:\n        throw new Error('this should never happen')\n    }\n  }\n\n  _updateBound() {\n    const bound = this._bound\n    this._oldbound = new Bound(this.bound.lower, this.bound.upper)\n    this.bound.lower = bound.lower\n  }\n\n  static _toUnit(value, unit = 'px') {\n    return value + unit\n  }\n}\n\nexport default SheetDrawer\n","import {\n  NAVSTATE_EVENTS,\n  NAV_BOX_SHADOW,\n  WINDOW,\n  ZERO,\n  css,\n  getAttribute,\n  getData\n} from '../util'\n\nconst TRANSITION_STYLE = 'ease'\nconst EFFECT = 'transition'\nconst TRANS_END = 'transitionend'\nconst SCROLL = 'scroll'\nconst HIDDEN = 'hidden'\n\n/**\n * This Service is pretty much similar to NavService\n * @see {@link ../nav/navservice.js}\n * \"Extend the NavService class\"; you may think, but\n * things will get a lot messy.\n * Some little bit of copy-and-paste and tweaking was done.\n */\nclass SheetService {\n  constructor(options, state) {\n    this.options = options\n    this.state = state\n    this.sheet = options.ELEMENT\n    this.button = options.INIT_ELEM\n    this.backdrop = options.BACKDROP\n    this.backdropElement = this.backdrop.backdrop\n    this._body = options.BODY\n    this.event = 'click'\n    this.direction = options.DIRECTION\n    this.height = this.sheet.offsetHeight\n    this.transTime = options.TRANSITION / 1e3\n    this.transition = `${this.direction} ${TRANSITION_STYLE} ${this.transTime}s`\n    // state of the nav, whether open or close\n    this.alive = false\n    // diff. btw. event triggered from Drawer class and on here\n    /**\n     * @private\n     */\n    this._closeInvoked = false\n    /**\n     * @readonly\n     * @private\n     */\n    this._initialState = SheetService.css(this.sheet, this.direction)\n    this._handlers = null\n  }\n\n  activate() {\n    const ClickHandler = (mouseEvent) => {\n      this.handler(mouseEvent)\n    }\n    const BackdropHandler = () => {\n      this._close()\n    }\n    const TransitionHandler = () => {\n      if (!this.alive && this._closeInvoked) {\n        this._cleanShadow()\n        this._closeInvoked = false\n      }\n    }\n    this._register({\n      ClickHandler,\n      BackdropHandler,\n      TransitionHandler\n    })\n\n    this.button.addEventListener(this.event, this._handlers.ClickHandler)\n    this.backdropElement.addEventListener(this.event, this._handlers.BackdropHandler)\n    if (this._initialState === `-${this._height('px')}`) {\n      this.sheet.addEventListener(TRANS_END, this._handlers.TransitionHandler)\n    }\n    return 0\n  }\n\n  deactivate() {\n    throw new ReferenceError('cannot deactivate a default service. This service must be kept running')\n  }\n\n  forceDeactivate() {\n    this.button.removeEventListener(this.event, this._handlers.ClickHandler)\n    this.backdropElement.removeEventListener(this.event, this._handlers.BackdropHandler)\n    if (this._initialState === `-${this._height('px')}`) {\n      this.sheet.removeEventListener(TRANS_END, this._handlers.TransitionHandler)\n    }\n    this._register(null)\n  }\n\n  handler(mouseEvent) {\n    mouseEvent.preventDefault()\n    const state = SheetService._toNum(SheetService.css(this.sheet, this.direction))\n    if (state < ZERO) {\n      const buttonHash = getAttribute(this.button, 'href') || getData(this.button, 'data-href')\n      if (buttonHash) {\n        WINDOW.location.hash = buttonHash\n      }\n      this._open()\n    } else {\n      this._close()\n    }\n  }\n\n  static css(el, property, style) {\n    return css(el, property, style)\n  }\n\n  static _toNum(val) {\n    val = val.replace(/[^\\d]*$/, '')\n    return /\\.(?=\\d)/.test(val) ? Math.round(parseFloat(val)) : parseInt(val, 10)\n  }\n\n  _height(unit) {\n    unit = unit || ''\n    return this.height + unit\n  }\n\n  _register(handler) {\n    this._handlers = handler\n  }\n\n  _open() {\n    const style = {\n      [this.direction]: ZERO,\n      [EFFECT]: this.transition,\n      boxShadow: NAV_BOX_SHADOW[this.direction]\n    }\n    SheetService.css(this.sheet, style)\n    this.backdrop.show(this.options.TRANSITION)\n    this._body.style.overflow = HIDDEN\n    // callback for when nav is shown\n    if (this.state.isRegisteredEvent(NAVSTATE_EVENTS.show)) {\n      this.state.getStateEventHandler(NAVSTATE_EVENTS.show)()\n    }\n    this.alive = true\n    this.state.activity.run()\n  }\n\n  _close() {\n    const style = {\n      [this.direction]: this._initialState,\n      [EFFECT]: this.transition\n      // don't clean shadow here\n      // it's transitioning\n    }\n    SheetService.css(this.sheet, style)\n    this.backdrop.hide(this.options.TRANSITION)\n    this._body.style.overflow = SCROLL\n    // callback for when nav is hidden\n    if (this.state.isRegisteredEvent(NAVSTATE_EVENTS.hide)) {\n      this.state.getStateEventHandler(NAVSTATE_EVENTS.hide)()\n    }\n    this.alive = false\n    this._closeInvoked = true\n    this.state.activity.derun()\n  }\n\n  _cleanShadow() {\n    SheetService.css(this.sheet, 'boxShadow', 'none')\n  }\n}\n\nexport default SheetService\n","import {\n  NAVSTATE_EVENTS, WINDOW\n} from './../util'\nimport NavCard from '../nav/index'\nimport SheetDrawer from './drawer'\nimport SheetService from './sheetservice'\n\nconst CLASS_TYPE = '[object Sheet]'\nconst NAME = 'Sheet'\nconst SHEET = WINDOW[NAME] || null\n\n\nclass Sheet extends NavCard {\n  constructor(src, dest) {\n    super(src, dest)\n    this.SheetService = null\n    Sheet.defaultConfig.threshold = 2 / 3\n  }\n\n  /**\n   * @override\n   */\n  setup(options) {\n    const navMountWorker = super.setup(options)\n    return new SheetMountWorker(this, navMountWorker.options)\n  }\n\n  /**\n   * @override\n   */\n  terminate(service) {\n    service |= 0\n    if (service & NavCard.SERVICES.Default && this.SheetService instanceof SheetService) {\n      this.SheetService.deactivate()\n    }\n    if (service & NavCard.SERVICES.Drawer && this.Drawer instanceof SheetDrawer) {\n      this.Drawer.deactivate()\n    }\n    if (service & NavCard.SERVICES.Pop && this.PopService) {\n      /**\n       * we can't strictly determine that `this.PopService`\n       * is an instance of PopService class.\n       * This is an edge case as there is no access to that\n       * type.\n       */\n      this.PopService.deactivate() // or super.terminate(...)\n    }\n    if (!service) {\n      throw new Error('a service id is required')\n    }\n  }\n\n  /**\n   * @override\n   */\n  toString() {\n    return CLASS_TYPE\n  }\n\n  /**\n   * @override\n   */\n  static namespace(name) {\n    WINDOW[name] = WINDOW[name] || {}\n    WINDOW[name][NAME] = Sheet\n    WINDOW[NAME] = SHEET\n  }\n\n  /**\n   * @override\n   */\n  _drawerAPI(options) {\n    const {\n      CustomDrawer\n    } = options\n    this.Drawer = CustomDrawer && typeof CustomDrawer === 'object' ? new CustomDrawer(options, this.State) : new SheetDrawer(options, this.State)\n    return {\n      activate: () => this.Drawer.activate(),\n      deactivate: () => this.Drawer.deactivate()\n    }\n  }\n\n  /**\n   * @override\n   */\n  _hashAPI(options) {\n    const Interface = super._hashAPI(options)\n    this.PopService.parentService = this.SheetService\n    return Interface\n  }\n\n  /**\n   * @override\n   */\n  _defaultAPI(options) {\n    this.SheetService = new SheetService(options, this.State)\n    return {\n      activate: () => this.SheetService.activate(),\n      deactivate: () => this.SheetService.deactivate()\n    }\n  }\n}\n\nclass SheetMountWorker {\n  constructor(borrowedContext, options) {\n    this.$this = borrowedContext\n    this.options = options\n  }\n\n  mount() {\n    const DEFAULT_ACTIVE = !this.$this._defaultAPI(this.options.defaultOptions).activate()\n    const DRAWER_ACTIVE = !this.$this._drawerAPI(this.options.drawerOptions).activate()\n    const HASH_ACTIVE = !this.$this._hashAPI(this.options.hashOptions).activate()\n    return new Promise((resolve, reject) => {\n      if (!(DEFAULT_ACTIVE && DRAWER_ACTIVE && HASH_ACTIVE)) {\n        reject(new Error('one or more services could not activate'))\n        return\n      }\n      resolve(new SheetStateEvent(this.$this, this.$this.State))\n    })\n  }\n\n  unmount() {\n    this.SheetService.forceDeactivate()\n    this.Drawer.deactivate()\n    this.PopService.deactivate()\n  }\n\n  toString() {\n    return '[object SheetMountWorker]'\n  }\n}\n\nclass SheetStateEvent {\n  constructor($this, state) {\n    this.events = [NAVSTATE_EVENTS.show, NAVSTATE_EVENTS.hide]\n    this.$this = $this\n    this._State = state\n  }\n\n  on(event, handle = () => false) {\n    if (!(this.events.indexOf(event) + 1)) {\n      throw new Error(`unknown event '${event}'`)\n    }\n    this._State[`on${event}`] = handle.bind(this.$this)\n  }\n\n  off(event) {\n    if (!(this.events.indexOf(event) + 1)) {\n      throw new Error(`unknown event '${event}'`)\n    }\n    this._State[`on${event}`] = null\n  }\n}\n\nexport default Sheet\n","import {\n  $,\n  Bound,\n  DIRECTIONS,\n  NAVSTATE_EVENTS,\n  NAV_BOX_SHADOW,\n  Path,\n  ZERO,\n  camelCase,\n  css,\n  dataCamelCase,\n  getAttribute,\n  getData,\n  hasAttribute,\n  resolveThreshold,\n  setAttribute,\n  unique\n} from './util'\nimport CircularPath from './circular-path'\nimport Drawer from './drawer'\nimport Nav from './nav'\nimport Sheet from './sheet'\n\n\nconst Util = {\n  NAV_BOX_SHADOW,\n  ZERO,\n  DIRECTIONS,\n  NAVSTATE_EVENTS,\n  Path,\n  Bound,\n  dataCamelCase,\n  camelCase,\n  unique,\n  $,\n  getAttribute,\n  hasAttribute,\n  setAttribute,\n  getData,\n  resolveThreshold,\n  css\n}\n\nexport {\n  CircularPath,\n  Drawer,\n  Nav,\n  Sheet,\n  Util\n}\n"]}